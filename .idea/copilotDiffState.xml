<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.chatait.panictutorgpt&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.chatait.panictutorgpt&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.code.gson:gson:2.13.1&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.chatait.panictutorgpt&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.chatait.panictutorgpt&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.code.gson:gson:2.13.1&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.os.Bundle&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications&#10;            )&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.app.*&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.os.*&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.*&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.*&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import java.util.Random&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private val CHANNEL_ID = &quot;default_channel&quot;&#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var geminiService: GeminiService&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // GeminiServiceを初期化&#10;        geminiService = GeminiService(this)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications)&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        createNotificationChannel()&#10;        requestNotificationPermission()&#10;&#10;        // アプリ起動時にAPIキーが設定されていない場合はダイアログを表示&#10;        checkAndShowApiKeyDialog()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;PanicTutor通知&quot;&#10;            val descriptionText = &quot;テスト予定の通知チャンネル&quot;&#10;            val importance = NotificationManager.IMPORTANCE_DEFAULT&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun requestNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS)&#10;                != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                ActivityCompat.requestPermissions(&#10;                    this,&#10;                    arrayOf(android.Manifest.permission.POST_NOTIFICATIONS),&#10;                    NOTIFICATION_PERMISSION_REQUEST_CODE&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun showNotification() {&#10;        // Android 13以降で通知パーミッションが付与されているか確認&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS)&#10;                != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;通知パーミッションが付与されていません&quot;)&#10;                Toast.makeText(this, &quot;通知パーミッションが必要です&quot;, Toast.LENGTH_SHORT).show()&#10;                return&#10;            }&#10;        }&#10;&#10;        val title = &quot;⚠️ テスト予定リマインダー&quot;&#10;        Log.d(&quot;MainActivity&quot;, &quot;リマインダー通知の生成を開始します&quot;)&#10;&#10;        // OpenAI APIを使って動的にメッセージを生成&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                val text = getRandomScaryMessage()&#10;                Log.d(&quot;MainActivity&quot;, &quot;メッセージ生成完了: $text&quot;)&#10;&#10;                val intent = Intent(this@MainActivity, MainActivity::class.java).apply {&#10;                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                }&#10;                val pendingIntentRequestCode = System.currentTimeMillis().toInt()&#10;                val pendingIntent: PendingIntent = PendingIntent.getActivity(&#10;                    this@MainActivity,&#10;                    pendingIntentRequestCode,&#10;                    intent,&#10;                    PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT&#10;                )&#10;&#10;                val builder = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)&#10;                    .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;                    .setContentTitle(title)&#10;                    .setContentText(text)&#10;                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;                    .setContentIntent(pendingIntent)&#10;                    .setAutoCancel(true)&#10;&#10;                try {&#10;                    with(NotificationManagerCompat.from(this@MainActivity)) {&#10;                        val notificationId = System.currentTimeMillis().toInt()&#10;                        notify(notificationId, builder.build())&#10;                        Log.d(&quot;MainActivity&quot;, &quot;通知を正常に送信しました (ID: $notificationId)&quot;)&#10;                    }&#10;&#10;                    saveNotificationToHistory(title, text)&#10;                    Log.d(&quot;MainActivity&quot;, &quot;通知履歴を保存しました&quot;)&#10;&#10;                } catch (e: SecurityException) {&#10;                    Log.e(&quot;MainActivity&quot;, &quot;通知送信に失敗しました - セキュリティエラー: ${e.message}&quot;)&#10;                    Toast.makeText(this@MainActivity, &quot;通知送信に失敗しました&quot;, Toast.LENGTH_SHORT).show()&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;MainActivity&quot;, &quot;通知送信中に予期しないエラーが発生しました: ${e.message}&quot;, e)&#10;                    Toast.makeText(this@MainActivity, &quot;通知送信エラーが発生しました&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;リマインダー生成中にエラーが発生しました: ${e.message}&quot;, e)&#10;                Toast.makeText(this@MainActivity, &quot;リマインダー生成に失敗しました&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getRandomScaryMessage(): String {&#10;        return geminiService.generateScaryMessage()&#10;    }&#10;&#10;    private fun saveNotificationToHistory(title: String, message: String) {&#10;        val prefs = getSharedPreferences(&quot;notification_history&quot;, MODE_PRIVATE)&#10;        val history = prefs.getStringSet(&quot;history&quot;, null)?.toMutableSet() ?: mutableSetOf()&#10;        val timestamp = java.text.SimpleDateFormat(&quot;MM/dd HH:mm&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        history.add(&quot;[$timestamp] $title|$message&quot;)&#10;&#10;        prefs.edit()&#10;            .putStringSet(&quot;history&quot;, history)&#10;            .apply()&#10;    }&#10;&#10;    private fun checkAndShowApiKeyDialog() {&#10;        if (!geminiService.isApiKeySet()) {&#10;            showApiKeySettingDialog()&#10;        }&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(this)&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setMessage(&quot;AIが生成する個性的な通知メッセージを受け取るには、Google Gemini APIキーの設定が必要です。&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;後で設定&quot;) { _, _ -&gt;&#10;                Toast.makeText(this, &quot;ホーム画面の通知ボタンを長押しで後から設定できます&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;            .setCancelable(false)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(this, &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(this, &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        when (requestCode) {&#10;            NOTIFICATION_PERMISSION_REQUEST_CODE -&gt; {&#10;                if (grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;                    // パーミッションが付与された&#10;                } else {&#10;                    // パーミッションが拒否された&#10;                }&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        private const val NOTIFICATION_PERMISSION_REQUEST_CODE = 1001&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(&quot;api_key&quot;, apiKey).apply()&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateScaryMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;&quot;&quot;&#10;                                        あなたは学生のテスト勉強を促す、少し脅迫的だが愛のあるリマインダーアシスタントです。&#10;                                        日本語で、短く（30文字以内）、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。&#10;                                        &#10;                                        例：&#10;                                        - 締め切りが迫っています！今すぐ勉強を！&#10;                                        - テスト当日まであとわずか...準備はお済み？&#10;                                        - 見て見ぬふりはできません...勉強しましょう&#10;                                        &#10;                                        テスト勉強をサボっている学生への短いリマインダーメッセージを生成してください。&#10;                                    &quot;&quot;&quot;.trimIndent()&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let {&#10;                        val geminiResponse = gson.fromJson(it, GeminiResponse::class.java)&#10;                        val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                        if (!aiMessage.isNullOrEmpty()) {&#10;                            Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIからメッセージを取得しました: $aiMessage&quot;)&#10;                            return@withContext aiMessage&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;Network error: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;Unexpected error: ${e.message}&quot;, e)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;,&#10;            &quot;もう逃げ場はありません...今すぐ勉強開始！&quot;,&#10;            &quot;このままでは本当にヤバいですよ？&quot;,&#10;            &quot;テスト結果が心配で夜も眠れません...&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // データクラス定義（Gemini 2.0 Flash API用）&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class OpenAIService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;openai_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;openai_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(&quot;api_key&quot;, apiKey).apply()&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateScaryMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;OpenAIService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;OpenAIService&quot;, &quot;OpenAI APIを呼び出します...&quot;)&#10;&#10;                val requestBody = OpenAIRequest(&#10;                    model = &quot;gpt-4o-mini&quot;,&#10;                    messages = listOf(&#10;                        Message(&#10;                            role = &quot;system&quot;,&#10;                            content = &quot;あなたは学生のテスト勉強を促す、少し脅迫的だが愛のあるリマインダーアシスタントです。日本語で、短く（30文字以内）、勉強を促す緊迫感のあるメッセージを生成してください。&quot;&#10;                        ),&#10;                        Message(&#10;                            role = &quot;user&quot;,&#10;                            content = &quot;テスト勉強をサボっている学生への短いリマインダーメッセージを生成してください。&quot;&#10;                        )&#10;                    ),&#10;                    max_tokens = 50,&#10;                    temperature = 0.8&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://api.openai.com/v1/chat/completions&quot;)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $apiKey&quot;)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let {&#10;                        val openAIResponse = gson.fromJson(it, OpenAIResponse::class.java)&#10;                        val aiMessage = openAIResponse.choices.firstOrNull()?.message?.content?.trim()&#10;                        if (!aiMessage.isNullOrEmpty()) {&#10;                            Log.d(&quot;OpenAIService&quot;, &quot;OpenAI APIからメッセージを取得しました: $aiMessage&quot;)&#10;                            return@withContext aiMessage&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.e(&quot;OpenAIService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                Log.e(&quot;OpenAIService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;OpenAIService&quot;, &quot;Network error: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OpenAIService&quot;, &quot;Unexpected error: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;OpenAIService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // データクラス定義&#10;    data class OpenAIRequest(&#10;        val model: String,&#10;        val messages: List&lt;Message&gt;,&#10;        val max_tokens: Int,&#10;        val temperature: Double&#10;    )&#10;&#10;    data class Message(&#10;        val role: String,&#10;        val content: String&#10;    )&#10;&#10;    data class OpenAIResponse(&#10;        val choices: List&lt;Choice&gt;&#10;    )&#10;&#10;    data class Choice(&#10;        val message: MessageResponse&#10;    )&#10;&#10;    data class MessageResponse(&#10;        val content: String&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import com.chatait.panictutorgpt.ui.dashboard.ScheduleItem&#10;&#10;class ScheduleRepository(context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;schedule_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        private const val KEY_SCHEDULE_PREFIX = &quot;schedule_&quot;&#10;        private const val KEY_SCHEDULE_DATES = &quot;schedule_dates&quot;&#10;    }&#10;&#10;    fun saveSchedules(schedules: List&lt;ScheduleItem&gt;) {&#10;        prefs.edit {&#10;            // すべての既存のスケジュールをクリア&#10;            val existingDates = getScheduleDates()&#10;            existingDates.forEach { date -&gt;&#10;                for (i in 0..5) { // 0限〜5限（6時限分）&#10;                    remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;                }&#10;            }&#10;            &#10;            // 新しいスケジュールを保存&#10;            val dates = schedules.map { it.date }.toSet()&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;            &#10;            schedules.forEach { schedule -&gt;&#10;                schedule.subjects.forEachIndexed { index, subject -&gt;&#10;                    putString(&quot;${KEY_SCHEDULE_PREFIX}${schedule.date}_subject_$index&quot;, subject)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadSchedules(): MutableList&lt;ScheduleItem&gt; {&#10;        val schedules = mutableListOf&lt;ScheduleItem&gt;()&#10;        val dates = getScheduleDates()&#10;        &#10;        dates.forEach { date -&gt;&#10;            val subjects = mutableListOf&lt;String&gt;()&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                val subject = prefs.getString(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;, &quot;&quot;) ?: &quot;&quot;&#10;                subjects.add(subject)&#10;            }&#10;            &#10;            // 空でない科目が1つでもあればスケジュールに追加&#10;            if (subjects.any { it.isNotEmpty() }) {&#10;                schedules.add(ScheduleItem(date, subjects))&#10;            }&#10;        }&#10;        &#10;        return schedules.sortedBy { it.date }.toMutableList()&#10;    }&#10;&#10;    fun deleteSchedule(date: String) {&#10;        prefs.edit {&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.remove(date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;&#10;    fun addOrUpdateSchedule(scheduleItem: ScheduleItem) {&#10;        prefs.edit {&#10;            scheduleItem.subjects.forEachIndexed { index, subject -&gt;&#10;                putString(&quot;${KEY_SCHEDULE_PREFIX}${scheduleItem.date}_subject_$index&quot;, subject)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.add(scheduleItem.date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;    &#10;    private fun getScheduleDates(): Set&lt;String&gt; {&#10;        return prefs.getStringSet(KEY_SCHEDULE_DATES, emptySet()) ?: emptySet()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(scheduleList) { dateToDelete -&gt;&#10;            // 削除処理&#10;            scheduleRepository.deleteSchedule(dateToDelete)&#10;            scheduleList.clear()&#10;            scheduleList.addAll(scheduleRepository.loadSchedules())&#10;            adapter.notifyDataSetChanged()&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    errorText.visibility = View.VISIBLE&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(scheduleList) { dateToDelete -&gt;&#10;            // 削除処理&#10;            scheduleRepository.deleteSchedule(dateToDelete)&#10;            scheduleList.clear()&#10;            scheduleList.addAll(scheduleRepository.loadSchedules())&#10;            adapter.notifyDataSetChanged()&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    // 既存データがある場合は削除確認ダイアログを表示&#10;                    if (existing != null) {&#10;                        // 一週間前チェック&#10;                        val testDate = Calendar.getInstance()&#10;                        val dateParts = date.split(&quot;/&quot;)&#10;                        testDate.set(dateParts[0].toInt(), dateParts[1].toInt() - 1, dateParts[2].toInt())&#10;&#10;                        val today = Calendar.getInstance()&#10;                        val oneWeekFromNow = Calendar.getInstance()&#10;                        oneWeekFromNow.add(Calendar.DAY_OF_YEAR, 7)&#10;&#10;                        if (testDate.before(oneWeekFromNow)) {&#10;                            // 一週間前を切っている場合は削除不可&#10;                            val warningDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;削除できません&quot;)&#10;                                .setMessage(&quot;テスト一週間前を切った予定は削除できません。&quot;)&#10;                                .setPositiveButton(&quot;OK&quot;, null)&#10;                                .create()&#10;                            warningDialog.show()&#10;                        } else {&#10;                            // 一週間前を切っていない場合は削除確認&#10;                            val deleteDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;確認&quot;)&#10;                                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                                    // 既存のスケジュールを削除&#10;                                    scheduleRepository.deleteSchedule(date)&#10;                                    // UIを更新&#10;                                    scheduleList.clear()&#10;                                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                                    adapter.notifyDataSetChanged()&#10;                                    dialog.dismiss()&#10;                                }&#10;                                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                                .create()&#10;                            deleteDialog.show()&#10;                        }&#10;                    } else {&#10;                        errorText.visibility = View.VISIBLE&#10;                    }&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;&#10;class ScheduleAdapter(&#10;    private val items: MutableList&lt;ScheduleItem&gt;,&#10;    private val onDeleteClick: ((String) -&gt; Unit)? = null&#10;) : RecyclerView.Adapter&lt;ScheduleAdapter.ViewHolder&gt;() {&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateText: TextView = view.findViewById(R.id.scheduleDate)&#10;        val subjectsText: TextView = view.findViewById(R.id.scheduleSubjects)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_schedule, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;        holder.dateText.text = item.date&#10;        holder.subjectsText.text = item.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;            .joinToString(&quot;\n&quot;) { (i, s) -&gt; &quot;${i+1}限: $s&quot; }&#10;&#10;        // 長押しで削除確認ダイアログを表示&#10;        holder.itemView.setOnLongClickListener {&#10;            AlertDialog.Builder(holder.itemView.context)&#10;                .setTitle(&quot;予定を削除&quot;)&#10;                .setMessage(&quot;${item.date}の予定を削除しますか？&quot;)&#10;                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                    onDeleteClick?.invoke(item.date)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .show()&#10;            true&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;&#10;class ScheduleAdapter(&#10;    private val items: MutableList&lt;ScheduleItem&gt;,&#10;    private val onDeleteClick: ((String) -&gt; Unit)? = null&#10;) : RecyclerView.Adapter&lt;ScheduleAdapter.ViewHolder&gt;() {&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateText: TextView = view.findViewById(R.id.scheduleDate)&#10;        val subjectsText: TextView = view.findViewById(R.id.scheduleSubjects)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_schedule, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;        holder.dateText.text = item.date&#10;        holder.subjectsText.text = item.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;            .joinToString(&quot;\n&quot;) { (i, s) -&gt; &quot;${i+1}限: $s&quot; }&#10;&#10;        // 5秒長押しで削除確認ダイアログを表示（削除不可期間でも強制削除可能）&#10;        var longPressHandler: Runnable? = null&#10;&#10;        // 元の背景色を保存&#10;        val originalBackground = holder.itemView.background&#10;&#10;        holder.itemView.setOnTouchListener { view, event -&gt;&#10;            when (event.action) {&#10;                android.view.MotionEvent.ACTION_DOWN -&gt; {&#10;                    // 長押し開始時に背景色を変更&#10;                    view.setBackgroundColor(ContextCompat.getColor(view.context, android.R.color.holo_red_light))&#10;&#10;                    longPressHandler = Runnable {&#10;                        // 5秒長押しの場合は削除不可期間でも強制削除確認&#10;                        // 元の背景色に戻す&#10;                        view.background = originalBackground&#10;&#10;                        AlertDialog.Builder(holder.itemView.context)&#10;                            .setTitle(&quot;予定を削除&quot;)&#10;                            .setMessage(&quot;本当に削除しますか？この操作は取り消せません。&quot;)&#10;                            .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                                onDeleteClick?.invoke(item.date)&#10;                            }&#10;                            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                            .show()&#10;                    }&#10;                    view.postDelayed(longPressHandler, 5000) // 5秒後に実行&#10;                }&#10;                android.view.MotionEvent.ACTION_UP,&#10;                android.view.MotionEvent.ACTION_CANCEL -&gt; {&#10;                    // 指を離したときに元の背景色に戻す&#10;                    view.background = originalBackground&#10;                    longPressHandler?.let { view.removeCallbacks(it) }&#10;                }&#10;            }&#10;            true&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;data class ScheduleItem(&#10;    val date: String, // 例: &quot;2025/08/03&quot;&#10;    val subjects: List&lt;String&gt; // 1限～6限の科目名&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.OpenAIService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 40),  // 2限&#10;        Pair(13, 0),   // 3限&#10;        Pair(14, 40),  // 4限&#10;        Pair(16, 20),  // 5限&#10;        Pair(18, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            (activity as? MainActivity)?.showNotification()&#10;            Toast.makeText(context, &quot;リマインダー通知を送信しました！&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val openAIService = OpenAIService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (openAIService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;OpenAI API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                openAIService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    // ...existing code...&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 40),  // 2限&#10;        Pair(13, 0),   // 3限&#10;        Pair(14, 40),  // 4限&#10;        Pair(16, 20),  // 5限&#10;        Pair(18, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            (activity as? MainActivity)?.showNotification()&#10;            Toast.makeText(context, &quot;リマインダー通知を送信しました！&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val geminiService = GeminiService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        handler.removeCallbacks(updateTimeRunnable)&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;        return root&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ArrayAdapter&#10;import android.widget.ListView&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var listView: ListView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;&#10;        // ListView を初期化し、通知履歴を表示&#10;        listView = binding.notificationList&#10;        loadNotificationHistory()&#10;&#10;        return root&#10;    }&#10;&#10;    private fun loadNotificationHistory() {&#10;        val prefs = requireContext().getSharedPreferences(&quot;notification_history&quot;, Context.MODE_PRIVATE)&#10;        val historySet = prefs.getStringSet(&quot;history&quot;, emptySet())&#10;&#10;        val historyList = if (historySet.isNullOrEmpty()) {&#10;            listOf(&quot;通知履歴はまだありません。\nHomeタブの「Entry」ボタンで通知を送信してください。&quot;)&#10;        } else {&#10;            historySet.map { historyItem -&gt;&#10;                val parts = historyItem.split(&quot;|&quot;)&#10;                val titleWithTime = parts.getOrNull(0) ?: &quot;タイトルなし&quot;&#10;                val message = parts.getOrNull(1) ?: &quot;メッセージなし&quot;&#10;                &quot;$titleWithTime\n$message&quot;&#10;            }.sortedDescending() // 新しい順に表示&#10;        }&#10;&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, historyList)&#10;        listView.adapter = adapter&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // フラグメントが表示されるたびに履歴を更新&#10;        loadNotificationHistory()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textError&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;科目名が入力されていません&quot;&#10;        android:textColor=&quot;#D32F2F&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_api_key_setting.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_api_key_setting.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Google Gemini API設定&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Google Gemini APIキーを入力してください。\nAPIキーを設定すると、AIが生成した個性的な通知メッセージを受け取れます。\n\n※ Gemini APIは無料で利用できます。&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Google Gemini APIキー&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&gt;&#10;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextApiKey&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:inputType=&quot;textPassword&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/buttonSaveApiKey&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;保存&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textViewStatus&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;APIキーが設定されていません&quot;&#10;        android:textColor=&quot;@android:color/holo_red_dark&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;CalendarView&#10;        android:id=&quot;@+id/calendarView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;CalendarView&#10;        android:id=&quot;@+id/calendarView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@+id/scheduleList&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/scheduleList&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/calendarView&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/dashboardEntryButton&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- HomeのEntryボタンと同じものを下部に追加（horizontal margin 24dp） --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/dashboardEntryButton&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;24dp&quot;&#10;        android:layout_marginEnd=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;100dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:text=&quot;テストの予定を追加&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintHorizontal_bias=&quot;1.0&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:text=&quot;通知履歴&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;ListView&#10;        android:id=&quot;@+id/notification_list&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        android:divider=&quot;#CCCCCC&quot;&#10;        android:dividerHeight=&quot;1dp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@+id/text_notifications&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>