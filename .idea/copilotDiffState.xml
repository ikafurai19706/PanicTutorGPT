<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- バックグラウンド脅迫通知サービス --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.ThreatNotificationService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.os.Bundle&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications&#10;            )&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.app.*&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.os.*&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuItem&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.*&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.*&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import java.util.Random&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private val CHANNEL_ID = &quot;default_channel&quot;&#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var geminiService: GeminiService&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // GeminiServiceを初期化&#10;        geminiService = GeminiService(this)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications)&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        createNotificationChannel()&#10;        requestNotificationPermission()&#10;&#10;        // アプリ起動時にAPIキーが設定されていない場合はダイアログを表示&#10;        checkAndShowApiKeyDialog()&#10;&#10;        // バックグラウンド脅迫サービスを開始&#10;        startThreatService()&#10;    }&#10;&#10;    private fun startThreatService() {&#10;        val serviceIntent = Intent(this, com.chatait.panictutorgpt.service.ThreatNotificationService::class.java)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            startForegroundService(serviceIntent)&#10;        } else {&#10;            startService(serviceIntent)&#10;        }&#10;        Log.d(&quot;MainActivity&quot;, &quot;脅迫サービスを開始しました&quot;)&#10;    }&#10;&#10;    private fun checkAndShowApiKeyDialog() {&#10;        if (!geminiService.isApiKeySet()) {&#10;            showApiKeyDialog()&#10;        }&#10;    }&#10;&#10;    private fun showApiKeyDialog() {&#10;        val editText = EditText(this)&#10;        editText.hint = &quot;Gemini API キーを入力してください&quot;&#10;&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;API キー設定&quot;)&#10;            .setMessage(&quot;Gemini API を使用してリマインダーメッセージを生成するため、API キーが必要です。&quot;)&#10;            .setView(editText)&#10;            .setPositiveButton(&quot;設定&quot;) { _, _ -&gt;&#10;                val apiKey = editText.text.toString().trim()&#10;                if (apiKey.isNotEmpty()) {&#10;                    geminiService.saveApiKey(apiKey)&#10;                    Toast.makeText(this, &quot;API キーが設定されました&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;API キーが空です&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;後で&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;                Toast.makeText(this, &quot;デフォルトメッセージを使用します&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Default Channel&quot;&#10;            val descriptionText = &quot;Default notification channel&quot;&#10;            val importance = NotificationManager.IMPORTANCE_DEFAULT&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun requestNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                ActivityCompat.requestPermissions(&#10;                    this,&#10;                    arrayOf(android.Manifest.permission.POST_NOTIFICATIONS),&#10;                    101&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendTestReminder() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val message = geminiService.generateReminderMessage()&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot;テスト勉強リマインダー&quot;, message)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;リマインダー送信時にエラーが発生しました: ${e.message}&quot;, e)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot;テスト勉強リマインダー&quot;, &quot;勉強を始めましょう！&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun showNotification(title: String, message: String) {&#10;        // 通知をタップした時にアプリを起動するためのIntent&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentTitle(title)&#10;            .setContentText(message)&#10;            .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;            .setAutoCancel(true)&#10;            .setContentIntent(pendingIntent) // 通知タップ時の動作を設定&#10;&#10;        with(NotificationManagerCompat.from(this)) {&#10;            if (ActivityCompat.checkSelfPermission(&#10;                    this@MainActivity,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                notify(Random().nextInt(), builder.build())&#10;            }&#10;        }&#10;    }&#10;&#10;    fun showApiKeySettingDialog() {&#10;        showApiKeyDialog()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // アプリがバックグラウンドに移行した時に脅迫メッセージをチェック&#10;        checkAndSendThreatMessage()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        // アプリが完全に閉じられた時にも脅迫メッセージをチェック&#10;        checkAndSendThreatMessage()&#10;    }&#10;&#10;    private fun checkAndSendThreatMessage() {&#10;        val scheduleRepository = com.chatait.panictutorgpt.data.ScheduleRepository(this)&#10;        val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(this)&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        &#10;        // 1週間以内のすべての科目が完了していたら通知をオフ&#10;        if (studyRepository.areAllSubjectsWithinOneWeekCompleted(schedules)) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;1週間以内のすべての科目が完了済みのため通知をスキップ&quot;)&#10;            return&#10;        }&#10;        &#10;        val upcomingTests = getTestsWithinOneWeek(scheduleRepository)&#10;&#10;        if (upcomingTests.isNotEmpty()) {&#10;            sendThreatNotification(upcomingTests)&#10;        }&#10;    }&#10;&#10;    private fun getTestsWithinOneWeek(scheduleRepository: com.chatait.panictutorgpt.data.ScheduleRepository): List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = java.text.SimpleDateFormat(&quot;yyyy/MM/dd&quot;, java.util.Locale.getDefault())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        return schedules.mapNotNull { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    val subjects = scheduleItem.subjects.filter { it.isNotBlank() }&#10;                    if (subjects.isNotEmpty()) {&#10;                        Pair(scheduleItem.date, subjects)&#10;                    } else null&#10;                } else null&#10;            } catch (e: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendThreatNotification(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val testInfo = upcomingTests.joinToString(&quot;、&quot;) { (date, subjects) -&gt;&#10;                    &quot;${date}: ${subjects.joinToString(&quot;、&quot;)}&quot;&#10;                }&#10;&#10;                val threatMessage = geminiService.generateThreatMessage(testInfo)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot; 緊急警告 &quot;, threatMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;脅迫メッセージ送信時にエラー: ${e.message}&quot;, e)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    val fallbackMessage = generateFallbackThreatMessage(upcomingTests)&#10;                    showNotification(&quot; 緊急警告 &quot;, fallbackMessage)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generateFallbackThreatMessage(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;): String {&#10;        val subjects = upcomingTests.flatMap { it.second }.distinct()&#10;        val threatMessages = listOf(&#10;            &quot;逃げても無駄です...${subjects.joinToString(&quot;、&quot;)}のテストが迫っています...&quot;,&#10;            &quot;アプリを閉じても現実は変わりません。${subjects.joinToString(&quot;、&quot;)}の準備はできていますか？&quot;,&#10;            &quot;恐怖の時間が始まります...${subjects.joinToString(&quot;、&quot;)}で良い点を取れなければ...&quot;,&#10;            &quot;運命の日が近づいています。${subjects.joinToString(&quot;、&quot;)}の勉強を怠れば後悔することになります...&quot;,&#10;            &quot;暗闇の中で${subjects.joinToString(&quot;、&quot;)}のテストがあなたを見つめています...&quot;,&#10;            &quot;時間は容赦なく過ぎています...${subjects.joinToString(&quot;、&quot;)}の準備はまだ終わっていませんね？&quot;&#10;        )&#10;        return threatMessages.random()&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu): Boolean {&#10;        menuInflater.inflate(R.menu.main_menu, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.menu_reset_all_data -&gt; {&#10;                showResetAllDataDialog()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showResetAllDataDialog() {&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;全履歴リセット&quot;)&#10;            .setMessage(&quot;スケジュールと勉強記録をすべて削除しますか？\n（APIキーは保持されます）&quot;)&#10;            .setIcon(android.R.drawable.ic_dialog_alert)&#10;            .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                resetAllData()&#10;            }&#10;            .setNegativeButton(&quot;キャンセル&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun resetAllData() {&#10;        try {&#10;            // スケジュールデータを削除&#10;            val scheduleRepository = com.chatait.panictutorgpt.data.ScheduleRepository(this)&#10;            scheduleRepository.clearAllSchedules()&#10;&#10;            // 勉強記録を削除&#10;            val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(this)&#10;            studyRepository.clearAllStudyRecords()&#10;&#10;            Toast.makeText(this, &quot;全履歴を削除しました&quot;, Toast.LENGTH_SHORT).show()&#10;            Log.d(&quot;MainActivity&quot;, &quot;全履歴削除が完了しました&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;履歴削除中にエラーが発生しました: ${e.message}&quot;, e)&#10;            Toast.makeText(this, &quot;削除中にエラーが発生しました&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;&quot;&quot;&#10;                                        あなたは学生のテスト勉強を促す、脅迫的なリマインダーアシスタントです。&#10;                                        日本語で、短く、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。&#10;                                    &quot;&quot;&quot;.trimIndent()&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;&quot;&quot;&#10;                                        あなたは学生のテスト勉強を促す、脅迫的なリマインダーアシスタントです。&#10;                                        日本語で、短く、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。&#10;                                    &quot;&quot;&quot;.trimIndent()&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun generateThreatMessage(testInfo: String): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバック脅迫メッセージを使用します。&quot;)&#10;                    return@withContext getThreatFallbackMessage(testInfo)&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIで脅迫メッセージを生成します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;あなたは学生に恐怖を与える悪魔的なテスト監督です。以下のテスト情報を元に、日本語で非常に脅迫的で恐ろしいメッセージを生成してください。アプリを閉じて逃げようとした学生を追い詰めるような、背筋が凍るような内容にしてください。絵文字を使って恐怖感を演出し、50文字以内で作成してください。\n\nテスト情報: $testInfo&quot;&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIから脅迫メッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージレスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージAPI request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージ予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    private fun getThreatFallbackMessage(testInfo: String): String {&#10;        val threatMessages = listOf(&#10;            &quot; 逃げても無駄...テストの恐怖があなたを追いかけます &quot;,&#10;            &quot; アプリを閉じても現実は変わらない...準備はできていますか？ &quot;,&#10;            &quot; 暗闇からテストがあなたを見つめています... &quot;,&#10;            &quot;⚡ 運命の時が近づいています...震えて待て ⚡&quot;,&#10;            &quot;️ 嵐のようなテストがやってきます...覚悟はいいですか？ ️&quot;,&#10;            &quot; 時間は容赦なく過ぎています...後悔の時が来る &quot;&#10;        )&#10;        val selectedMessage = threatMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバック脅迫メッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;あなたは学生のテスト勉強を促す、少し脅迫的だが愛のあるリマインダーアシスタントです。日本語で、短く（30文字以内）、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。テスト勉強をサボっている学生への短いリマインダーメッセージをお願いします。&quot;&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import com.chatait.panictutorgpt.ui.dashboard.ScheduleItem&#10;&#10;class ScheduleRepository(context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;schedule_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        private const val KEY_SCHEDULE_PREFIX = &quot;schedule_&quot;&#10;        private const val KEY_SCHEDULE_DATES = &quot;schedule_dates&quot;&#10;    }&#10;&#10;    fun saveSchedules(schedules: List&lt;ScheduleItem&gt;) {&#10;        prefs.edit {&#10;            // すべての既存のスケジュールをクリア&#10;            val existingDates = getScheduleDates()&#10;            existingDates.forEach { date -&gt;&#10;                for (i in 0..5) { // 0限〜5限（6時限分）&#10;                    remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;                }&#10;            }&#10;            &#10;            // 新しいスケジュールを保存&#10;            val dates = schedules.map { it.date }.toSet()&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;            &#10;            schedules.forEach { schedule -&gt;&#10;                schedule.subjects.forEachIndexed { index, subject -&gt;&#10;                    putString(&quot;${KEY_SCHEDULE_PREFIX}${schedule.date}_subject_$index&quot;, subject)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadSchedules(): MutableList&lt;ScheduleItem&gt; {&#10;        val schedules = mutableListOf&lt;ScheduleItem&gt;()&#10;        val dates = getScheduleDates()&#10;        &#10;        dates.forEach { date -&gt;&#10;            val subjects = mutableListOf&lt;String&gt;()&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                val subject = prefs.getString(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;, &quot;&quot;) ?: &quot;&quot;&#10;                subjects.add(subject)&#10;            }&#10;            &#10;            // 空でない科目が1つでもあればスケジュールに追加&#10;            if (subjects.any { it.isNotEmpty() }) {&#10;                schedules.add(ScheduleItem(date, subjects))&#10;            }&#10;        }&#10;        &#10;        return schedules.sortedBy { it.date }.toMutableList()&#10;    }&#10;&#10;    fun deleteSchedule(date: String) {&#10;        prefs.edit {&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.remove(date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;&#10;    fun addOrUpdateSchedule(scheduleItem: ScheduleItem) {&#10;        prefs.edit {&#10;            scheduleItem.subjects.forEachIndexed { index, subject -&gt;&#10;                putString(&quot;${KEY_SCHEDULE_PREFIX}${scheduleItem.date}_subject_$index&quot;, subject)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.add(scheduleItem.date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;    &#10;    private fun getScheduleDates(): Set&lt;String&gt; {&#10;        return prefs.getStringSet(KEY_SCHEDULE_DATES, emptySet()) ?: emptySet()&#10;    }&#10;&#10;    fun clearAllSchedules() {&#10;        prefs.edit {&#10;            // すべてのスケジュール関連データを削除&#10;            val existingDates = getScheduleDates()&#10;            existingDates.forEach { date -&gt;&#10;                for (i in 0..5) { // 0限〜5限（6時限分）&#10;                    remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;                }&#10;            }&#10;            remove(KEY_SCHEDULE_DATES)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/StudyRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/StudyRepository.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;data class StudyRecord(&#10;    val date: String,           // テスト日付&#10;    val subject: String,        // 科目名&#10;    val period: Int,           // 時限&#10;    val studyDate: String,     // 勉強した日付 (新規追加)&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;class StudyRepository(private val context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;study_records&quot;, Context.MODE_PRIVATE)&#10;    private val gson = Gson()&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;    fun saveStudyRecord(studyRecord: StudyRecord) {&#10;        val existingRecords = getStudyRecords().toMutableList()&#10;&#10;        // 同じテスト日付・科目・時限・勉強日付の記録があれば更新、なければ追加&#10;        val existingIndex = existingRecords.indexOfFirst {&#10;            it.date == studyRecord.date &amp;&amp;&#10;            it.subject == studyRecord.subject &amp;&amp;&#10;            it.period == studyRecord.period &amp;&amp;&#10;            it.studyDate == studyRecord.studyDate  // 勉強日付も比較に追加&#10;        }&#10;&#10;        if (existingIndex != -1) {&#10;            // 同じ日に同じ科目を勉強した記録があれば更新&#10;            existingRecords[existingIndex] = studyRecord&#10;        } else {&#10;            // 新しい日の勉強記録として追加&#10;            existingRecords.add(studyRecord)&#10;        }&#10;&#10;        val json = gson.toJson(existingRecords)&#10;        prefs.edit().putString(&quot;study_records&quot;, json).apply()&#10;    }&#10;&#10;    fun getStudyRecords(): List&lt;StudyRecord&gt; {&#10;        val json = prefs.getString(&quot;study_records&quot;, null) ?: return emptyList()&#10;        val type = object : TypeToken&lt;List&lt;StudyRecord&gt;&gt;() {}.type&#10;        return gson.fromJson(json, type)&#10;    }&#10;&#10;    fun getAllStudyRecords(): List&lt;StudyRecord&gt; {&#10;        return getStudyRecords().sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    fun getStudyRecordsForDate(date: String): List&lt;StudyRecord&gt; {&#10;        return getStudyRecords().filter { it.date == date }&#10;    }&#10;&#10;    fun isSubjectStudiedToday(date: String, subject: String, period: Int): Boolean {&#10;        val today = dateFormat.format(Date())&#10;        val allStudyRecords = getStudyRecords()&#10;&#10;        // 今日勉強した記録から、指定されたテスト日付・科目・時限に一致するものを探す&#10;        return allStudyRecords.any { record -&gt;&#10;            record.studyDate == today &amp;&amp;  // 今日勉強した&#10;            record.date == date &amp;&amp;        // テスト日付が一致&#10;            record.subject == subject &amp;&amp;  // 科目が一致&#10;            record.period == period       // 時限が一致&#10;        }&#10;    }&#10;&#10;    fun areAllSubjectsStudiedForDate(scheduleItem: com.chatait.panictutorgpt.ui.dashboard.ScheduleItem): Boolean {&#10;        val today = dateFormat.format(Date())&#10;        val allStudyRecords = getStudyRecords()&#10;&#10;        // その日の全科目を取得&#10;        val allSubjects = scheduleItem.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;            .map { (index, subject) -&gt; Triple(scheduleItem.date, subject, index + 1) }&#10;&#10;        if (allSubjects.isEmpty()) return false&#10;&#10;        // すべての科目が今日勉強されているかチェック&#10;        return allSubjects.all { (date, subject, period) -&gt;&#10;            allStudyRecords.any { record -&gt;&#10;                record.studyDate == today &amp;&amp;  // 今日勉強した&#10;                record.date == date &amp;&amp;        // テスト日付が一致&#10;                record.subject == subject &amp;&amp;  // 科目が一致&#10;                record.period == period       // 時限が一致&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearOldRecords() {&#10;        // 7日以前の記録を削除&#10;        val sevenDaysAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;        val recentRecords = getStudyRecords().filter { it.timestamp &gt; sevenDaysAgo }&#10;&#10;        val json = gson.toJson(recentRecords)&#10;        prefs.edit().putString(&quot;study_records&quot;, json).apply()&#10;    }&#10;&#10;    fun clearAllStudyRecords() {&#10;        // すべての勉強記録を削除&#10;        prefs.edit().remove(&quot;study_records&quot;).apply()&#10;    }&#10;&#10;    fun getStudyRecordsForStudyDate(studyDate: String): List&lt;StudyRecord&gt; {&#10;        // 指定した勉強日の記録を取得&#10;        return getStudyRecords().filter { it.studyDate == studyDate }&#10;    }&#10;&#10;    fun getStudyHistoryByDate(): Map&lt;String, List&lt;StudyRecord&gt;&gt; {&#10;        // 勉強日別にグループ化した履歴を取得&#10;        return getStudyRecords()&#10;            .groupBy { it.studyDate }&#10;            .toSortedMap(compareByDescending { it })&#10;    }&#10;&#10;    fun areAllSubjectsWithinOneWeekCompleted(schedules: List&lt;com.chatait.panictutorgpt.ui.dashboard.ScheduleItem&gt;): Boolean {&#10;        val today = dateFormat.format(Date())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        // 1週間以内のテスト科目を取得&#10;        val subjectsWithinOneWeek = schedules.flatMap { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    scheduleItem.subjects.withIndex()&#10;                        .filter { it.value.isNotBlank() }&#10;                        .map { (index, subject) -&gt;&#10;                            Triple(scheduleItem.date, subject, index + 1)&#10;                        }&#10;                } else {&#10;                    emptyList()&#10;                }&#10;            } catch (e: Exception) {&#10;                emptyList()&#10;            }&#10;        }&#10;&#10;        if (subjectsWithinOneWeek.isEmpty()) return false&#10;&#10;        val allStudyRecords = getStudyRecords()&#10;&#10;        // 1週間以内のすべての科目が今日勉強されているかチェック&#10;        return subjectsWithinOneWeek.all { (date, subject, period) -&gt;&#10;            allStudyRecords.any { record -&gt;&#10;                record.studyDate == today &amp;&amp;  // 今日勉強した&#10;                record.date == date &amp;&amp;        // テスト日付が一致&#10;                record.subject == subject &amp;&amp;  // 科目が一致&#10;                record.period == period       // 時限が一致&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/service/ThreatNotificationService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/service/ThreatNotificationService.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.service&#10;&#10;import android.app.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import kotlinx.coroutines.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class ThreatNotificationService : Service() {&#10;&#10;    private val CHANNEL_ID = &quot;threat_channel&quot;&#10;    private val NOTIFICATION_ID = 1001&#10;    private lateinit var geminiService: GeminiService&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var serviceJob: Job? = null&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        geminiService = GeminiService(this)&#10;        scheduleRepository = ScheduleRepository(this)&#10;        createNotificationChannel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが開始されました&quot;)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        startForegroundService()&#10;        startThreatMonitoring()&#10;        return START_STICKY // サービスが強制終了されても自動的に再起動&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;監視システム&quot;)&#10;            .setContentText(&quot;テスト期間中の逃亡を監視中...&quot;)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    private fun startThreatMonitoring() {&#10;        serviceJob = CoroutineScope(Dispatchers.IO + SupervisorJob()).launch {&#10;            while (isActive) {&#10;                try {&#10;                    checkAndSendThreatMessage()&#10;                    delay(TimeUnit.MINUTES.toMillis(30)) // 30分ごとにチェック&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージチェック中にエラー: ${e.message}&quot;)&#10;                    delay(TimeUnit.MINUTES.toMillis(10)) // エラー時は10分後に再試行&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkAndSendThreatMessage() {&#10;        val upcomingTests = getTestsWithinOneWeek()&#10;&#10;        if (upcomingTests.isNotEmpty()) {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のテストが発見されました: $upcomingTests&quot;)&#10;            sendThreatNotification(upcomingTests)&#10;        } else {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のテストはありません&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getTestsWithinOneWeek(): List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        return schedules.mapNotNull { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    val subjects = scheduleItem.subjects.filter { it.isNotBlank() }&#10;                    if (subjects.isNotEmpty()) {&#10;                        Pair(scheduleItem.date, subjects)&#10;                    } else null&#10;                } else null&#10;            } catch (e: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun sendThreatNotification(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;) {&#10;        try {&#10;            val testInfo = upcomingTests.joinToString(&quot;、&quot;) { (date, subjects) -&gt;&#10;                &quot;${date}: ${subjects.joinToString(&quot;、&quot;)}&quot;&#10;            }&#10;&#10;            val threatMessage = geminiService.generateThreatMessage(testInfo)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, threatMessage)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージ生成エラー: ${e.message}&quot;)&#10;            val fallbackMessage = generateFallbackThreatMessage(upcomingTests)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, fallbackMessage)&#10;        }&#10;    }&#10;&#10;    private fun showThreatNotification(title: String, message: String) {&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentTitle(title)&#10;            .setContentText(message)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;            .setContentIntent(pendingIntent)&#10;            .setVibrate(longArrayOf(0, 1000, 500, 1000)) // 振動パターン&#10;            .setLights(0xFFFF0000.toInt(), 1000, 1000) // 赤色LEDライト&#10;            .build()&#10;&#10;        with(NotificationManagerCompat.from(this)) {&#10;            if (ActivityCompat.checkSelfPermission(&#10;                    this@ThreatNotificationService,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                notify(Random().nextInt(1000, 9999), notification)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知を送信しました: $message&quot;)&#10;    }&#10;&#10;    private fun generateFallbackThreatMessage(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;): String {&#10;        val subjects = upcomingTests.flatMap { it.second }.distinct()&#10;        val threatMessages = listOf(&#10;            &quot; どこに隠れても無駄です...${subjects.joinToString(&quot;、&quot;)}のテストから逃れることはできません &quot;,&#10;            &quot; アプリを閉じて逃げたつもりですか？${subjects.joinToString(&quot;、&quot;)}の恐怖があなたを追いかけます &quot;,&#10;            &quot; 暗闇の中から${subjects.joinToString(&quot;、&quot;)}のテストがあなたを見つめています... &quot;,&#10;            &quot;⚡ 運命から逃れることはできません...${subjects.joinToString(&quot;、&quot;)}の審判の時が来ました ⚡&quot;,&#10;            &quot;️ 嵐のような${subjects.joinToString(&quot;、&quot;)}のテストがあなたを襲います...覚悟はできていますか？ ️&quot;,&#10;            &quot; 時間は刻一刻と過ぎています...${subjects.joinToString(&quot;、&quot;)}の準備を怠った代償を払う時です &quot;&#10;        )&#10;        return threatMessages.random()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;脅迫通知チャンネル&quot;&#10;            val descriptionText = &quot;テスト期間中の脅迫メッセージ&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;                enableVibration(true)&#10;                enableLights(true)&#10;                lightColor = 0xFFFF0000.toInt()&#10;            }&#10;            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        serviceJob?.cancel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが停止されました&quot;)&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.service&#10;&#10;import android.app.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import kotlinx.coroutines.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class ThreatNotificationService : Service() {&#10;&#10;    private val CHANNEL_ID = &quot;threat_channel&quot;&#10;    private val NOTIFICATION_ID = 1001&#10;    private lateinit var geminiService: GeminiService&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var serviceJob: Job? = null&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        geminiService = GeminiService(this)&#10;        scheduleRepository = ScheduleRepository(this)&#10;        createNotificationChannel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが開始されました&quot;)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        startForegroundService()&#10;        startThreatMonitoring()&#10;        return START_STICKY // サービスが強制終了されても自動的に再起動&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;監視システム&quot;)&#10;            .setContentText(&quot;テスト期間中の逃亡を監視中...&quot;)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    private fun startThreatMonitoring() {&#10;        serviceJob = CoroutineScope(Dispatchers.IO + SupervisorJob()).launch {&#10;            while (isActive) {&#10;                try {&#10;                    checkAndSendThreatMessage()&#10;                    delay(TimeUnit.MINUTES.toMillis(30)) // 30分ごとにチェック&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージチェック中にエラー: ${e.message}&quot;)&#10;                    delay(TimeUnit.MINUTES.toMillis(10)) // エラー時は10分後に再試行&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkAndSendThreatMessage() {&#10;        val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(this)&#10;        val schedules = scheduleRepository.loadSchedules()&#10;&#10;        // 1週間以内のすべての科目が完了していたら通知をオフ&#10;        if (studyRepository.areAllSubjectsWithinOneWeekCompleted(schedules)) {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のすべての科目が完了済みのため通知をスキップ&quot;)&#10;            return&#10;        }&#10;&#10;        val upcomingTests = getTestsWithinOneWeek()&#10;&#10;        if (upcomingTests.isNotEmpty()) {&#10;            // 勉強記録をチェックして、すべて勉強済みの日は除外&#10;            val testsNeedingStudy = upcomingTests.filter { (date, subjects) -&gt;&#10;                // その日のスケジュールアイテムを取得&#10;                val scheduleItem = scheduleRepository.loadSchedules().find { it.date == date }&#10;                scheduleItem?.let { schedule -&gt;&#10;                    // すべての科目が勉強済みでない場合のみ通知対象&#10;                    !studyRepository.areAllSubjectsStudiedForDate(schedule)&#10;                } ?: true // スケジュールが見つからない場合は通知対象&#10;            }&#10;&#10;            if (testsNeedingStudy.isNotEmpty()) {&#10;                Log.d(&quot;ThreatService&quot;, &quot;勉強が必要なテスト: $testsNeedingStudy&quot;)&#10;                sendThreatNotification(testsNeedingStudy)&#10;            } else {&#10;                Log.d(&quot;ThreatService&quot;, &quot;すべてのテストの勉強が完了しています&quot;)&#10;            }&#10;        } else {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のテストはありません&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getTestsWithinOneWeek(): List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        return schedules.mapNotNull { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    val subjects = scheduleItem.subjects.filter { it.isNotBlank() }&#10;                    if (subjects.isNotEmpty()) {&#10;                        Pair(scheduleItem.date, subjects)&#10;                    } else null&#10;                } else null&#10;            } catch (e: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun sendThreatNotification(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;) {&#10;        try {&#10;            val testInfo = upcomingTests.joinToString(&quot;、&quot;) { (date, subjects) -&gt;&#10;                &quot;${date}: ${subjects.joinToString(&quot;、&quot;)}&quot;&#10;            }&#10;&#10;            val threatMessage = geminiService.generateThreatMessage(testInfo)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, threatMessage)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージ生成エラー: ${e.message}&quot;)&#10;            val fallbackMessage = generateFallbackThreatMessage(upcomingTests)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, fallbackMessage)&#10;        }&#10;    }&#10;&#10;    private fun showThreatNotification(title: String, message: String) {&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentTitle(title)&#10;            .setContentText(message)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;            .setContentIntent(pendingIntent)&#10;            .setVibrate(longArrayOf(0, 1000, 500, 1000)) // 振動パターン&#10;            .setLights(0xFFFF0000.toInt(), 1000, 1000) // 赤色LEDライト&#10;            .build()&#10;&#10;        with(NotificationManagerCompat.from(this)) {&#10;            if (ActivityCompat.checkSelfPermission(&#10;                    this@ThreatNotificationService,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                notify(Random().nextInt(1000, 9999), notification)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知を送信しました: $message&quot;)&#10;    }&#10;&#10;    private fun generateFallbackThreatMessage(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;): String {&#10;        val subjects = upcomingTests.flatMap { it.second }.distinct()&#10;        val threatMessages = listOf(&#10;            &quot; どこに隠れても無駄です...${subjects.joinToString(&quot;、&quot;)}のテストから逃れることはできません &quot;,&#10;            &quot; アプリを閉じて逃げたつもりですか？${subjects.joinToString(&quot;、&quot;)}の恐怖があなたを追いかけます &quot;,&#10;            &quot; 暗闇の中から${subjects.joinToString(&quot;、&quot;)}のテストがあなたを見つめています... &quot;,&#10;            &quot;⚡ 運命から逃れることはできません...${subjects.joinToString(&quot;、&quot;)}の審判の時が来ました ⚡&quot;,&#10;            &quot;️ 嵐のような${subjects.joinToString(&quot;、&quot;)}のテストがあなたを襲います...覚悟はできていますか？ ️&quot;,&#10;            &quot; 時間は刻一刻と過ぎています...${subjects.joinToString(&quot;、&quot;)}の準備を怠った代償を払う時です &quot;&#10;        )&#10;        return threatMessages.random()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;脅迫通知チャンネル&quot;&#10;            val descriptionText = &quot;テスト期間中の脅迫メッセージ&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;                enableVibration(true)&#10;                enableLights(true)&#10;                lightColor = 0xFFFF0000.toInt()&#10;            }&#10;            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        serviceJob?.cancel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが停止されました&quot;)&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(scheduleList) { dateToDelete -&gt;&#10;            // 削除処理&#10;            scheduleRepository.deleteSchedule(dateToDelete)&#10;            scheduleList.clear()&#10;            scheduleList.addAll(scheduleRepository.loadSchedules())&#10;            adapter.notifyDataSetChanged()&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    errorText.visibility = View.VISIBLE&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // StudyRepositoryを初期化&#10;        val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(&#10;            items = scheduleList,&#10;            onDeleteClick = { itemId -&gt;&#10;                // IDで削除処理&#10;                val itemToDelete = scheduleList.find { it.id == itemId }&#10;                if (itemToDelete != null) {&#10;                    scheduleRepository.deleteSchedule(itemToDelete.date)&#10;                    adapter.removeItem(itemId)&#10;                }&#10;            },&#10;            onItemClick = { item -&gt;&#10;                // アイテムクリック時の編集処理&#10;                showEditScheduleForm(item)&#10;            },&#10;            onEmptyScheduleDelete = { itemId -&gt;&#10;                // 空スケジュール削除処理&#10;                val itemToDelete = scheduleList.find { it.id == itemId }&#10;                if (itemToDelete != null) {&#10;                    scheduleRepository.deleteSchedule(itemToDelete.date)&#10;                    adapter.removeItem(itemId)&#10;                }&#10;            },&#10;            studyRepository = studyRepository // StudyRepositoryを渡す&#10;        )&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // カレンダービューの設定&#10;        setupCalendarView()&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    // 既存データがある場合は削除確認ダイアログを表示&#10;                    if (existing != null) {&#10;                        // 一週間前チェック&#10;                        val testDate = Calendar.getInstance()&#10;                        val dateParts = date.split(&quot;/&quot;)&#10;                        testDate.set(dateParts[0].toInt(), dateParts[1].toInt() - 1, dateParts[2].toInt())&#10;&#10;                        val today = Calendar.getInstance()&#10;                        val oneWeekFromNow = Calendar.getInstance()&#10;                        oneWeekFromNow.add(Calendar.DAY_OF_YEAR, 7)&#10;&#10;                        if (testDate.before(oneWeekFromNow)) {&#10;                            // 一週間前を切っている場合は削除不可&#10;                            val warningDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;削除できません&quot;)&#10;                                .setMessage(&quot;テスト一週間前を切った予定は削除できません。&quot;)&#10;                                .setPositiveButton(&quot;OK&quot;, null)&#10;                                .create()&#10;                            warningDialog.show()&#10;                        } else {&#10;                            // 一週間前を切っていない場合は削除確認&#10;                            val deleteDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;確認&quot;)&#10;                                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                                    // 既存のスケジュールを削除&#10;                                    scheduleRepository.deleteSchedule(date)&#10;                                    // UIを更新&#10;                                    scheduleList.clear()&#10;                                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                                    adapter.notifyDataSetChanged()&#10;                                    dialog.dismiss()&#10;                                }&#10;                                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                                .create()&#10;                            deleteDialog.show()&#10;                        }&#10;                    } else {&#10;                        errorText.visibility = View.VISIBLE&#10;                    }&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    // 編集用のフォームを表示する関数&#10;    private fun showEditScheduleForm(item: ScheduleItem) {&#10;        val dateParts = item.date.split(&quot;/&quot;)&#10;        if (dateParts.size == 3) {&#10;            val year = dateParts[0].toInt()&#10;            val month = dateParts[1].toInt() - 1 // Calendarは0ベース&#10;            val day = dateParts[2].toInt()&#10;            showAddScheduleForm(year, month, day)&#10;        }&#10;    }&#10;&#10;    // カレンダービューの設定&#10;    private fun setupCalendarView() {&#10;        binding.calendarView.apply {&#10;            // 日付クリック時の処理&#10;            setOnDateChangeListener { _, year, month, dayOfMonth -&gt;&#10;                val selectedDate = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, dayOfMonth)&#10;&#10;                // 選択された日付のテスト予定を表示&#10;                val existingSchedule = scheduleList.find { it.date == selectedDate }&#10;                if (existingSchedule != null) {&#10;                    showScheduleDetailsDialog(existingSchedule)&#10;                } else {&#10;                    // 予定がない場合は新規追加フォームを表示&#10;                    showAddScheduleForm(year, month, dayOfMonth)&#10;                }&#10;            }&#10;&#10;            // 今日の日付に設定&#10;            val today = Calendar.getInstance()&#10;            date = today.timeInMillis&#10;        }&#10;    }&#10;&#10;    // 選択された日付のテスト予定詳細を表示&#10;    private fun showScheduleDetailsDialog(schedule: ScheduleItem) {&#10;        val subjects = schedule.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;            .joinToString(&quot;\n&quot;) { (index, subject) -&gt; &quot;${index + 1}限: $subject&quot; }&#10;&#10;        val message = if (subjects.isEmpty()) {&#10;            &quot;この日はテスト予定がありません&quot;&#10;        } else {&#10;            &quot; ${schedule.date}\n\n$subjects&quot;&#10;        }&#10;&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;テスト予定&quot;)&#10;            .setMessage(message)&#10;            .setPositiveButton(&quot;編集&quot;) { _, _ -&gt;&#10;                showEditScheduleForm(schedule)&#10;            }&#10;            .setNegativeButton(&quot;閉じる&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.animation.ValueAnimator&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.text.SpannableStringBuilder&#10;import android.text.Spanned&#10;import android.text.style.ForegroundColorSpan&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.StudyRepository&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ScheduleAdapter(&#10;    private val items: MutableList&lt;ScheduleItem&gt;,&#10;    private val onDeleteClick: ((String) -&gt; Unit)? = null,&#10;    private val onItemClick: ((ScheduleItem) -&gt; Unit)? = null,&#10;    private val onEmptyScheduleDelete: ((String) -&gt; Unit)? = null,&#10;    private val studyRepository: StudyRepository? = null&#10;) : RecyclerView.Adapter&lt;ScheduleAdapter.ViewHolder&gt;() {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#10;    private var longPressRunnable: Runnable? = null&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateText: TextView = view.findViewById(R.id.scheduleDate)&#10;        val subjectsText: TextView = view.findViewById(R.id.scheduleSubjects)&#10;        val cardView: View = view&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_schedule, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;        holder.dateText.text = item.date&#10;&#10;        // 空でない科目のみ表示（チェックマーク付き＋色付き）&#10;        val nonEmptySubjects = item.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;&#10;        if (nonEmptySubjects.isEmpty()) {&#10;            holder.subjectsText.text = &quot;テスト予定なし&quot;&#10;        } else {&#10;            val spannableBuilder = SpannableStringBuilder()&#10;&#10;            nonEmptySubjects.forEachIndexed { index, (i, subject) -&gt;&#10;                val period = i + 1&#10;                val isStudied = studyRepository?.isSubjectStudiedToday(item.date, subject, period) == true&#10;&#10;                val text = if (isStudied) {&#10;                    &quot;${period}限: $subject ✓&quot;&#10;                } else {&#10;                    &quot;${period}限: $subject&quot;&#10;                }&#10;&#10;                val startIndex = spannableBuilder.length&#10;                spannableBuilder.append(text)&#10;                val endIndex = spannableBuilder.length&#10;&#10;                // 勉強完了した科目は緑色に&#10;                if (isStudied) {&#10;                    val greenColor = Color.parseColor(&quot;#4CAF50&quot;) // マテリアルデザインの緑色&#10;                    spannableBuilder.setSpan(&#10;                        ForegroundColorSpan(greenColor),&#10;                        startIndex,&#10;                        endIndex,&#10;                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE&#10;                    )&#10;                }&#10;&#10;                // 最後の項目以外は改行を追加&#10;                if (index &lt; nonEmptySubjects.size - 1) {&#10;                    spannableBuilder.append(&quot;\n&quot;)&#10;                }&#10;            }&#10;&#10;            holder.subjectsText.text = spannableBuilder&#10;        }&#10;&#10;        // タッチリスナー設定（長押し処理と通常クリック処理を統合）&#10;        holder.cardView.setOnTouchListener { view, event -&gt;&#10;            when (event.action) {&#10;                MotionEvent.ACTION_DOWN -&gt; {&#10;                    startLongPressAnimation(view)&#10;                    startLongPressTimer(view, item)&#10;                    true&#10;                }&#10;                MotionEvent.ACTION_UP -&gt; {&#10;                    val wasLongPressCompleted = longPressRunnable == null&#10;                    cancelLongPress(view)&#10;                    if (!wasLongPressCompleted) {&#10;                        // 長押しが完了していない場合のみ通常クリック&#10;                        onItemClick?.invoke(item)&#10;                    }&#10;                    // 長押しが完了した場合は何もしない（削除ダイアログは既に表示済み）&#10;                    true&#10;                }&#10;                MotionEvent.ACTION_CANCEL -&gt; {&#10;                    cancelLongPress(view)&#10;                    true&#10;                }&#10;                else -&gt; false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    private fun startLongPressAnimation(view: View) {&#10;        // CardViewの元の背景を保存&#10;        val originalBackground = view.background&#10;&#10;        // 色付きオーバーレイを作成してCardViewのスタイルを保持&#10;        val originalColor = 0x00FF0000 // 透明な赤&#10;        val pressedColor = 0xAAFF0000.toInt() // 半透明の赤&#10;&#10;        val colorAnimator = ValueAnimator.ofArgb(originalColor, pressedColor)&#10;        colorAnimator.duration = 5000 // 5秒&#10;        colorAnimator.addUpdateListener { animator -&gt;&#10;            // オーバーレイ色でCardViewのスタイルを保持したまま色を変更&#10;            view.setBackgroundColor(animator.animatedValue as Int)&#10;            // 元の背景の上に色を重ねる効果を実現&#10;            view.foreground = android.graphics.drawable.ColorDrawable(animator.animatedValue as Int)&#10;        }&#10;        colorAnimator.start()&#10;&#10;        // タグにアニメーターと元の背景を保存&#10;        view.tag = mapOf(&quot;animator&quot; to colorAnimator, &quot;originalBackground&quot; to originalBackground)&#10;    }&#10;&#10;    private fun startLongPressTimer(view: View, item: ScheduleItem) {&#10;        longPressRunnable = Runnable {&#10;            // タイマー実行時にrunnableをnullにして、ACTION_UPで通常クリックが実行されないようにする&#10;            longPressRunnable = null&#10;            showForcedDeleteDialog(view.context, item)&#10;        }&#10;        longPressHandler.postDelayed(longPressRunnable!!, 5000) // 5秒&#10;    }&#10;&#10;    private fun cancelLongPress(view: View) {&#10;        longPressRunnable?.let { runnable -&gt;&#10;            longPressHandler.removeCallbacks(runnable)&#10;            longPressRunnable = null&#10;        }&#10;&#10;        // 保存されたアニメーターと元の背景を取得&#10;        val tagMap = view.tag as? Map&lt;String, Any&gt;&#10;        val animator = tagMap?.get(&quot;animator&quot;) as? ValueAnimator&#10;        val originalBackground = tagMap?.get(&quot;originalBackground&quot;)&#10;&#10;        // アニメーション停止&#10;        animator?.cancel()&#10;&#10;        // CardViewを完全に元の状態に復元&#10;        if (originalBackground != null) {&#10;            view.background = originalBackground as android.graphics.drawable.Drawable&#10;        }&#10;&#10;        // オーバーレイを削除&#10;        view.foreground = null&#10;&#10;        view.tag = null&#10;    }&#10;&#10;    private fun showForcedDeleteDialog(context: android.content.Context, item: ScheduleItem) {&#10;        AlertDialog.Builder(context)&#10;            .setTitle(&quot;削除確認&quot;)&#10;            .setMessage(&quot;本当に削除しますか？この操作は取り消せません。&quot;)&#10;            .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                onDeleteClick?.invoke(item.id)&#10;            }&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun isWithinOneWeek(dateString: String): Boolean {&#10;        return try {&#10;            val testDate = dateFormat.parse(dateString)&#10;            val currentDate = Date()&#10;            val oneWeekFromNow = Calendar.getInstance().apply {&#10;                time = currentDate&#10;                add(Calendar.DAY_OF_YEAR, 7)&#10;            }.time&#10;&#10;            testDate != null &amp;&amp; testDate.before(oneWeekFromNow)&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    fun showDeleteConfirmationForEmptySchedule(context: android.content.Context, item: ScheduleItem) {&#10;        if (isWithinOneWeek(item.date)) {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除不可&quot;)&#10;                .setMessage(&quot;一週間前を切ったテストの予定は削除できません。&quot;)&#10;                .setPositiveButton(&quot;OK&quot;, null)&#10;                .show()&#10;        } else {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除確認&quot;)&#10;                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                    onEmptyScheduleDelete?.invoke(item.id)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .show()&#10;        }&#10;    }&#10;&#10;    fun removeItem(itemId: String) {&#10;        val position = items.indexOfFirst { it.id == itemId }&#10;        if (position != -1) {&#10;            items.removeAt(position)&#10;            notifyItemRemoved(position)&#10;        }&#10;    }&#10;&#10;    fun updateItem(updatedItem: ScheduleItem) {&#10;        val position = items.indexOfFirst { it.id == updatedItem.id }&#10;        if (position != -1) {&#10;            items[position] = updatedItem&#10;            notifyItemChanged(position)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.animation.ValueAnimator&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.text.SpannableStringBuilder&#10;import android.text.Spanned&#10;import android.text.style.ForegroundColorSpan&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.StudyRepository&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ScheduleAdapter(&#10;    private val items: MutableList&lt;ScheduleItem&gt;,&#10;    private val onDeleteClick: ((String) -&gt; Unit)? = null,&#10;    private val onItemClick: ((ScheduleItem) -&gt; Unit)? = null,&#10;    private val onEmptyScheduleDelete: ((String) -&gt; Unit)? = null,&#10;    private val studyRepository: StudyRepository? = null&#10;) : RecyclerView.Adapter&lt;ScheduleAdapter.ViewHolder&gt;() {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    private val displayDateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#10;    private var longPressRunnable: Runnable? = null&#10;&#10;    private fun isPastDate(dateString: String): Boolean {&#10;        return try {&#10;            val testDate = displayDateFormat.parse(dateString)&#10;            val today = Calendar.getInstance().apply {&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }.time&#10;            testDate != null &amp;&amp; testDate.before(today)&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateText: TextView = view.findViewById(R.id.scheduleDate)&#10;        val subjectsText: TextView = view.findViewById(R.id.scheduleSubjects)&#10;        val cardView: View = view&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_schedule, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;        holder.dateText.text = item.date&#10;&#10;        // 空でない科目のみ表示（チェックマーク付き＋色付き）&#10;        val nonEmptySubjects = item.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;&#10;        if (nonEmptySubjects.isEmpty()) {&#10;            holder.subjectsText.text = &quot;テスト予定なし&quot;&#10;        } else {&#10;            val spannableBuilder = SpannableStringBuilder()&#10;&#10;            nonEmptySubjects.forEachIndexed { index, (i, subject) -&gt;&#10;                val period = i + 1&#10;                val isStudied = studyRepository?.isSubjectStudiedToday(item.date, subject, period) == true&#10;&#10;                val text = if (isStudied) {&#10;                    &quot;${period}限: $subject ✓&quot;&#10;                } else {&#10;                    &quot;${period}限: $subject&quot;&#10;                }&#10;&#10;                val startIndex = spannableBuilder.length&#10;                spannableBuilder.append(text)&#10;                val endIndex = spannableBuilder.length&#10;&#10;                // 勉強完了した科目は緑色に&#10;                if (isStudied) {&#10;                    val greenColor = Color.parseColor(&quot;#4CAF50&quot;) // マテリアルデザインの緑色&#10;                    spannableBuilder.setSpan(&#10;                        ForegroundColorSpan(greenColor),&#10;                        startIndex,&#10;                        endIndex,&#10;                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE&#10;                    )&#10;                }&#10;&#10;                // 最後の項目以外は改行を追加&#10;                if (index &lt; nonEmptySubjects.size - 1) {&#10;                    spannableBuilder.append(&quot;\n&quot;)&#10;                }&#10;            }&#10;&#10;            holder.subjectsText.text = spannableBuilder&#10;        }&#10;&#10;        // タッチリスナー設定（過去のテストは編集不可）&#10;        if (isPastDate(item.date)) {&#10;            // 過去のテストはタッチ操作を無効化&#10;            holder.cardView.setOnTouchListener(null)&#10;            holder.cardView.isClickable = false&#10;            holder.cardView.isLongClickable = false&#10;&#10;            // 過去のテストであることを視覚的に示す（少し暗くする）&#10;            holder.cardView.alpha = 0.7f&#10;        } else {&#10;            // 現在または未来のテストは通常通りタッチ操作を有効化&#10;            holder.cardView.alpha = 1.0f&#10;            holder.cardView.isClickable = true&#10;            holder.cardView.isLongClickable = true&#10;&#10;            holder.cardView.setOnTouchListener { view, event -&gt;&#10;                when (event.action) {&#10;                    MotionEvent.ACTION_DOWN -&gt; {&#10;                        startLongPressAnimation(view)&#10;                        startLongPressTimer(view, item)&#10;                        true&#10;                    }&#10;                    MotionEvent.ACTION_UP -&gt; {&#10;                        val wasLongPressCompleted = longPressRunnable == null&#10;                        cancelLongPress(view)&#10;                        if (!wasLongPressCompleted) {&#10;                            // 長押しが完了していない場合のみ通常クリック&#10;                            onItemClick?.invoke(item)&#10;                        }&#10;                        // 長押しが完了した場合は何もしない（削除ダイアログは既に表示済み）&#10;                        true&#10;                    }&#10;                    MotionEvent.ACTION_CANCEL -&gt; {&#10;                        cancelLongPress(view)&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    private fun startLongPressAnimation(view: View) {&#10;        // CardViewの元の背景を保存&#10;        val originalBackground = view.background&#10;&#10;        // 色付きオーバーレイを作成してCardViewのスタイルを保持&#10;        val originalColor = 0x00FF0000 // 透明な赤&#10;        val pressedColor = 0xAAFF0000.toInt() // 半透明の赤&#10;&#10;        val colorAnimator = ValueAnimator.ofArgb(originalColor, pressedColor)&#10;        colorAnimator.duration = 5000 // 5秒&#10;        colorAnimator.addUpdateListener { animator -&gt;&#10;            // オーバーレイ色でCardViewのスタイルを保持したまま色を変更&#10;            view.setBackgroundColor(animator.animatedValue as Int)&#10;            // 元の背景の上に色を重ねる効果を実現&#10;            view.foreground = android.graphics.drawable.ColorDrawable(animator.animatedValue as Int)&#10;        }&#10;        colorAnimator.start()&#10;&#10;        // タグにアニメーターと元の背景を保存&#10;        view.tag = mapOf(&quot;animator&quot; to colorAnimator, &quot;originalBackground&quot; to originalBackground)&#10;    }&#10;&#10;    private fun startLongPressTimer(view: View, item: ScheduleItem) {&#10;        longPressRunnable = Runnable {&#10;            // タイマー実行時にrunnableをnullにして、ACTION_UPで通常クリックが実行されないようにする&#10;            longPressRunnable = null&#10;            showForcedDeleteDialog(view.context, item)&#10;        }&#10;        longPressHandler.postDelayed(longPressRunnable!!, 5000) // 5秒&#10;    }&#10;&#10;    private fun cancelLongPress(view: View) {&#10;        longPressRunnable?.let { runnable -&gt;&#10;            longPressHandler.removeCallbacks(runnable)&#10;            longPressRunnable = null&#10;        }&#10;&#10;        // 保存されたアニメーターと元の背景を取得&#10;        val tagMap = view.tag as? Map&lt;String, Any&gt;&#10;        val animator = tagMap?.get(&quot;animator&quot;) as? ValueAnimator&#10;        val originalBackground = tagMap?.get(&quot;originalBackground&quot;)&#10;&#10;        // アニメーション停止&#10;        animator?.cancel()&#10;&#10;        // CardViewを完全に元の状態に復元&#10;        if (originalBackground != null) {&#10;            view.background = originalBackground as android.graphics.drawable.Drawable&#10;        }&#10;&#10;        // オーバーレイを削除&#10;        view.foreground = null&#10;&#10;        view.tag = null&#10;    }&#10;&#10;    private fun showForcedDeleteDialog(context: android.content.Context, item: ScheduleItem) {&#10;        AlertDialog.Builder(context)&#10;            .setTitle(&quot;削除確認&quot;)&#10;            .setMessage(&quot;本当に削除しますか？この操作は取り消せません。&quot;)&#10;            .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                onDeleteClick?.invoke(item.id)&#10;            }&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun isWithinOneWeek(dateString: String): Boolean {&#10;        return try {&#10;            val testDate = dateFormat.parse(dateString)&#10;            val currentDate = Date()&#10;            val oneWeekFromNow = Calendar.getInstance().apply {&#10;                time = currentDate&#10;                add(Calendar.DAY_OF_YEAR, 7)&#10;            }.time&#10;&#10;            testDate != null &amp;&amp; testDate.before(oneWeekFromNow)&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    fun showDeleteConfirmationForEmptySchedule(context: android.content.Context, item: ScheduleItem) {&#10;        if (isWithinOneWeek(item.date)) {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除不可&quot;)&#10;                .setMessage(&quot;一週間前を切ったテストの予定は削除できません。&quot;)&#10;                .setPositiveButton(&quot;OK&quot;, null)&#10;                .show()&#10;        } else {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除確認&quot;)&#10;                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                    onEmptyScheduleDelete?.invoke(item.id)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .show()&#10;        }&#10;    }&#10;&#10;    fun removeItem(itemId: String) {&#10;        val position = items.indexOfFirst { it.id == itemId }&#10;        if (position != -1) {&#10;            items.removeAt(position)&#10;            notifyItemRemoved(position)&#10;        }&#10;    }&#10;&#10;    fun updateItem(updatedItem: ScheduleItem) {&#10;        val position = items.indexOfFirst { it.id == updatedItem.id }&#10;        if (position != -1) {&#10;            items[position] = updatedItem&#10;            notifyItemChanged(position)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;data class ScheduleItem(&#10;    val date: String, // 例: &quot;2025/08/03&quot;&#10;    val subjects: List&lt;String&gt;, // 1限～6限の科目名&#10;    val id: String = java.util.UUID.randomUUID().toString()&#10;)&#10;&#10;// 表示用のアイテムタイプ&#10;sealed class DisplayItem {&#10;    data class Schedule(val scheduleItem: ScheduleItem) : DisplayItem()&#10;    data class PastTestsHeader(&#10;        val pastTests: List&lt;ScheduleItem&gt;,&#10;        val isExpanded: Boolean = false,&#10;        val id: String = &quot;past_tests_header&quot;&#10;    ) : DisplayItem()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/ChecklistAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/ChecklistAdapter.kt" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.CheckBox&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;&#10;data class ChecklistItem(&#10;    val date: String,&#10;    val subject: String,&#10;    val period: Int,&#10;    var isChecked: Boolean = false,&#10;    val isDateHeader: Boolean = false&#10;)&#10;&#10;class ChecklistAdapter(private val items: MutableList&lt;ChecklistItem&gt;) : &#10;    RecyclerView.Adapter&lt;ChecklistAdapter.ViewHolder&gt;() {&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateHeader: TextView = view.findViewById(R.id.textDateHeader)&#10;        val checkboxSubject: CheckBox = view.findViewById(R.id.checkboxSubject)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_study_checklist, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;&#10;        if (item.isDateHeader) {&#10;            // 日付ヘッダー表示&#10;            holder.dateHeader.visibility = View.VISIBLE&#10;            holder.dateHeader.text = &quot; ${item.date}&quot;&#10;            holder.checkboxSubject.visibility = View.GONE&#10;        } else {&#10;            // 科目チェックボックス表示&#10;            holder.dateHeader.visibility = View.GONE&#10;            holder.checkboxSubject.visibility = View.VISIBLE&#10;            holder.checkboxSubject.text = &quot;${item.period}限: ${item.subject}&quot;&#10;            holder.checkboxSubject.isChecked = item.isChecked&#10;&#10;            // チェックボックスのクリックリスナー&#10;            holder.checkboxSubject.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isChecked = isChecked&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun getCheckedItems(): List&lt;ChecklistItem&gt; {&#10;        return items.filter { it.isChecked &amp;&amp; !it.isDateHeader }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 20),  // 2限&#10;        Pair(11, 40),   // 3限&#10;        Pair(13, 20),  // 4限&#10;        Pair(14, 40),  // 5限&#10;        Pair(16, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            // テスト一覧をチェックリスト形式で表示&#10;            showStudyChecklistDialog()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            (activity as? MainActivity)?.showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd\nHH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val geminiService = GeminiService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * 勉強完了時にチェックリスト形式でダイアログを表示する&#10;     */&#10;    private fun showStudyChecklistDialog() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;&#10;        if (schedules.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;テスト予定が登録されていません&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // 日付ごとにグループ化してチェックリスト項目を作成&#10;        val checklistItems = mutableListOf&lt;ChecklistItem&gt;()&#10;&#10;        schedules.sortedBy { it.date }.forEach { scheduleItem -&gt;&#10;            var hasSubjects = false&#10;&#10;            // 各科目をチェック&#10;            scheduleItem.subjects.forEachIndexed { index, subject -&gt;&#10;                if (subject.isNotBlank()) {&#10;                    if (!hasSubjects) {&#10;                        // 最初の科目の前に日付ヘッダーを追加&#10;                        checklistItems.add(ChecklistItem(&#10;                            date = scheduleItem.date,&#10;                            subject = &quot;&quot;,&#10;                            period = 0,&#10;                            isDateHeader = true&#10;                        ))&#10;                        hasSubjects = true&#10;                    }&#10;&#10;                    // 科目のチェックボックスを追加&#10;                    checklistItems.add(ChecklistItem(&#10;                        date = scheduleItem.date,&#10;                        subject = subject,&#10;                        period = index + 1,&#10;                        isChecked = false&#10;                    ))&#10;                }&#10;            }&#10;        }&#10;&#10;        if (checklistItems.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;勉強できる科目が見つかりません&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // ダイアログを表示&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_study_checklist, null)&#10;        val recyclerView = dialogView.findViewById&lt;androidx.recyclerview.widget.RecyclerView&gt;(R.id.recyclerViewChecklist)&#10;        val buttonClose = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonCloseChecklist)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveProgress)&#10;&#10;        // チェックリストアダプターをセット&#10;        val checklistAdapter = ChecklistAdapter(checklistItems)&#10;        recyclerView.adapter = checklistAdapter&#10;        recyclerView.layoutManager = androidx.recyclerview.widget.LinearLayoutManager(requireContext())&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot; 勉強した科目を選択&quot;)&#10;            .setView(dialogView)&#10;            .setCancelable(false)&#10;            .create()&#10;&#10;        // 完了ボタン&#10;        buttonClose.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        // 保存ボタン&#10;        buttonSave.setOnClickListener {&#10;            val checkedItems = checklistAdapter.getCheckedItems()&#10;            if (checkedItems.isNotEmpty()) {&#10;                val studiedSubjects = checkedItems.joinToString(&quot;、&quot;) { &quot;${it.date} ${it.period}限: ${it.subject}&quot; }&#10;                Toast.makeText(&#10;                    requireContext(),&#10;                    &quot;お疲れさまでした！\n勉強した科目: $studiedSubjects&quot;,&#10;                    Toast.LENGTH_LONG&#10;                ).show()&#10;                // TODO: 実際の勉強記録保存機能を実装予定&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;勉強した科目を選択してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        handler.removeCallbacks(updateTimeRunnable)&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 20),  // 2限&#10;        Pair(11, 40),   // 3限&#10;        Pair(13, 20),  // 4限&#10;        Pair(14, 40),  // 5限&#10;        Pair(16, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            // テスト一覧をチェックリスト形式で表示&#10;            showStudyChecklistDialog()&#10;        }&#10;&#10;        // 勉強履歴表示ボタン&#10;        binding.studyHistoryButton.setOnClickListener {&#10;            showStudyHistoryDialog()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            (activity as? MainActivity)?.showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd\nHH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val geminiService = GeminiService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * 勉強完了時にチェックリスト形式でダイアログを表示する&#10;     */&#10;    private fun showStudyChecklistDialog() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;&#10;        if (schedules.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;テスト予定が登録されていません&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // 日付ごとにグループ化してチェックリスト項目を作成&#10;        val checklistItems = mutableListOf&lt;ChecklistItem&gt;()&#10;&#10;        schedules.sortedBy { it.date }.forEach { scheduleItem -&gt;&#10;            var hasSubjects = false&#10;&#10;            // 各科目をチェック&#10;            scheduleItem.subjects.forEachIndexed { index, subject -&gt;&#10;                if (subject.isNotBlank()) {&#10;                    if (!hasSubjects) {&#10;                        // 最初の科目の前に日付ヘッダーを追加&#10;                        checklistItems.add(ChecklistItem(&#10;                            date = scheduleItem.date,&#10;                            subject = &quot;&quot;,&#10;                            period = 0,&#10;                            isDateHeader = true&#10;                        ))&#10;                        hasSubjects = true&#10;                    }&#10;&#10;                    // 科目のチェックボックスを追加&#10;                    checklistItems.add(ChecklistItem(&#10;                        date = scheduleItem.date,&#10;                        subject = subject,&#10;                        period = index + 1,&#10;                        isChecked = false&#10;                    ))&#10;                }&#10;            }&#10;        }&#10;&#10;        if (checklistItems.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;勉強できる科目が見つかりません&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // ダイアログを表示&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_study_checklist, null)&#10;        val recyclerView = dialogView.findViewById&lt;androidx.recyclerview.widget.RecyclerView&gt;(R.id.recyclerViewChecklist)&#10;        val buttonClose = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonCloseChecklist)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveProgress)&#10;&#10;        // チェックリストアダプターをセット&#10;        val checklistAdapter = ChecklistAdapter(checklistItems)&#10;        recyclerView.adapter = checklistAdapter&#10;        recyclerView.layoutManager = androidx.recyclerview.widget.LinearLayoutManager(requireContext())&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot; 勉強した科目を選択&quot;)&#10;            .setView(dialogView)&#10;            .setCancelable(false)&#10;            .create()&#10;&#10;        // 完了ボタン&#10;        buttonClose.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        // 保存ボタン&#10;        buttonSave.setOnClickListener {&#10;            val checkedItems = checklistAdapter.getCheckedItems()&#10;            if (checkedItems.isNotEmpty()) {&#10;                // 勉強記録を保存&#10;                val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(requireContext())&#10;                val today = java.text.SimpleDateFormat(&quot;yyyy/MM/dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;                &#10;                checkedItems.forEach { item -&gt;&#10;                    val studyRecord = com.chatait.panictutorgpt.data.StudyRecord(&#10;                        date = item.date,&#10;                        subject = item.subject,&#10;                        period = item.period,&#10;                        studyDate = today  // 勉強した日付を追加&#10;                    )&#10;                    studyRepository.saveStudyRecord(studyRecord)&#10;                }&#10;&#10;                val studiedSubjects = checkedItems.joinToString(&quot;、&quot;) { &quot;${it.date} ${it.period}限: ${it.subject}&quot; }&#10;                Toast.makeText(&#10;                    requireContext(),&#10;                    &quot;お疲れさまでした！\n勉強した科目: $studiedSubjects&quot;,&#10;                    Toast.LENGTH_LONG&#10;                ).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;勉強した科目を選択してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showStudyHistoryDialog() {&#10;        val studyRepository = com.chatait.panictutorgpt.data.StudyRepository(requireContext())&#10;        val studyRecords = studyRepository.getAllStudyRecords()&#10;&#10;        if (studyRecords.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;勉強履歴がありません&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // 勉強履歴を表示するダイアログを作成&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_study_history, null)&#10;        val recyclerView = dialogView.findViewById&lt;androidx.recyclerview.widget.RecyclerView&gt;(R.id.recyclerViewStudyHistory)&#10;        val buttonClose = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonCloseHistory)&#10;&#10;        // 勉強履歴アダプターをセット&#10;        val historyAdapter = StudyHistoryAdapter(studyRecords)&#10;        recyclerView.adapter = historyAdapter&#10;        recyclerView.layoutManager = androidx.recyclerview.widget.LinearLayoutManager(requireContext())&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot; 勉強履歴&quot;)&#10;            .setView(dialogView)&#10;            .setCancelable(false)&#10;            .create()&#10;&#10;        // 閉じるボタン&#10;        buttonClose.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        handler.removeCallbacks(updateTimeRunnable)&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/StudyHistoryAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/StudyHistoryAdapter.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.StudyRecord&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class StudyHistoryAdapter(private val studyRecords: List&lt;StudyRecord&gt;) :&#10;    RecyclerView.Adapter&lt;StudyHistoryAdapter.ViewHolder&gt;() {&#10;&#10;    private val dateTimeFormat = SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;, Locale.getDefault())&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val textStudyDate: TextView = view.findViewById(R.id.textStudyDate)&#10;        val textSubjectInfo: TextView = view.findViewById(R.id.textSubjectInfo)&#10;        val textStudyTime: TextView = view.findViewById(R.id.textStudyTime)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_study_history, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val record = studyRecords[position]&#10;&#10;        holder.textStudyDate.text = &quot; ${record.date}&quot;&#10;        holder.textSubjectInfo.text = &quot;${record.period}限: ${record.subject}&quot;&#10;        holder.textStudyTime.text = &quot;勉強完了: ${dateTimeFormat.format(Date(record.timestamp))}&quot;&#10;    }&#10;&#10;    override fun getItemCount(): Int = studyRecords.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;        return root&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ArrayAdapter&#10;import android.widget.ListView&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var listView: ListView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;&#10;        // ListView を初期化し、通知履歴を表示&#10;        listView = binding.notificationList&#10;        loadNotificationHistory()&#10;&#10;        return root&#10;    }&#10;&#10;    private fun loadNotificationHistory() {&#10;        val prefs = requireContext().getSharedPreferences(&quot;notification_history&quot;, Context.MODE_PRIVATE)&#10;        val historySet = prefs.getStringSet(&quot;history&quot;, emptySet())&#10;&#10;        val historyList = if (historySet.isNullOrEmpty()) {&#10;            listOf(&quot;通知履歴はまだありません。\nHomeタブの「Entry」ボタンで通知を送信してください。&quot;)&#10;        } else {&#10;            historySet.map { historyItem -&gt;&#10;                val parts = historyItem.split(&quot;|&quot;)&#10;                val titleWithTime = parts.getOrNull(0) ?: &quot;タイトルなし&quot;&#10;                val message = parts.getOrNull(1) ?: &quot;メッセージなし&quot;&#10;                &quot;$titleWithTime\n$message&quot;&#10;            }.sortedDescending() // 新しい順に表示&#10;        }&#10;&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, historyList)&#10;        listView.adapter = adapter&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // フラグメントが表示されるたびに履歴を更新&#10;        loadNotificationHistory()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/test_date_marker.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/test_date_marker.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;oval&quot;&gt;&#10;    &lt;solid android:color=&quot;#FF5722&quot; /&gt;&#10;    &lt;size android:width=&quot;8dp&quot; android:height=&quot;8dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textError&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;科目名が入力されていません&quot;&#10;        android:textColor=&quot;#D32F2F&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_study_checklist.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_study_checklist.xml" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;勉強した科目にチェックを入れてください&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerViewChecklist&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:maxHeight=&quot;400dp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;end&quot;&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/buttonCloseChecklist&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;キャンセル&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot;&#10;            style=&quot;?android:attr/buttonBarButtonStyle&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/buttonSaveProgress&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;保存&quot;&#10;            style=&quot;?android:attr/buttonBarButtonStyle&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_study_history.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_study_history.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;これまでの勉強履歴を表示しています&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerViewStudyHistory&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:maxHeight=&quot;400dp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/buttonCloseHistory&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;閉じる&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        style=&quot;?android:attr/buttonBarButtonStyle&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;CalendarView&#10;        android:id=&quot;@+id/calendarView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;FrameLayout&#10;        android:id=&quot;@+id/calendarContainer&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@+id/scheduleList&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;CalendarView&#10;            android:id=&quot;@+id/calendarView&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;match_parent&quot; /&gt;&#10;&#10;        &lt;!-- テスト予定マーカー用のオーバーレイ --&gt;&#10;        &lt;FrameLayout&#10;            android:id=&quot;@+id/calendarOverlay&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;match_parent&quot; /&gt;&#10;&#10;    &lt;/FrameLayout&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/scheduleList&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/calendarContainer&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/dashboardEntryButton&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- HomeのEntryボタンと同じものを下部に追加（horizontal margin 24dp） --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/dashboardEntryButton&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;24dp&quot;&#10;        android:layout_marginEnd=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;100dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:text=&quot;テストの予定を追加&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintHorizontal_bias=&quot;1.0&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:gravity=&quot;center_horizontal&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;24dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/dateTimeText&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:textSize=&quot;36sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        tools:text=&quot;2025/08/03 08:33:51.24&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/countdownTestText&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:textColor=&quot;@android:color/holo_red_dark&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        tools:text=&quot;テストまで残り 08:34:15.72&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;AnalogClock&#10;        android:id=&quot;@+id/analogClock&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;32dp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/registerButton&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:text=&quot; 勉強した！&quot;&#10;        android:textSize=&quot;20sp&quot; /&gt;&#10;&lt;/LinearLayout&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:gravity=&quot;center_horizontal&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;24dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/dateTimeText&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:textSize=&quot;36sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        tools:text=&quot;2025/08/03 08:33:51.24&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/countdownTestText&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:textColor=&quot;@android:color/holo_red_dark&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        tools:text=&quot;テストまで残り 08:34:15.72&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;AnalogClock&#10;        android:id=&quot;@+id/analogClock&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginBottom=&quot;32dp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/registerButton&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:text=&quot; 勉強した！&quot;&#10;        android:textSize=&quot;20sp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/studyHistoryButton&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:padding=&quot;12dp&quot;&#10;        android:text=&quot; 勉強履歴を見る&quot;&#10;        android:textSize=&quot;16sp&quot; /&gt;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:text=&quot;通知履歴&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;ListView&#10;        android:id=&quot;@+id/notification_list&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        android:divider=&quot;#CCCCCC&quot;&#10;        android:dividerHeight=&quot;1dp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@+id/text_notifications&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_past_tests_header.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_past_tests_header.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.cardview.widget.CardView&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    card_view:cardElevation=&quot;2dp&quot;&#10;    card_view:cardCornerRadius=&quot;8dp&quot;&#10;    card_view:cardUseCompatPadding=&quot;true&quot;&#10;    android:layout_margin=&quot;8dp&quot;&#10;    card_view:cardBackgroundColor=&quot;#F0F0F0&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:gravity=&quot;center_vertical&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/expandIcon&quot;&#10;            android:layout_width=&quot;24dp&quot;&#10;            android:layout_height=&quot;24dp&quot;&#10;            android:src=&quot;@android:drawable/arrow_down_float&quot;&#10;            android:layout_marginEnd=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/headerTitle&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;過去のテスト&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#666666&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/pastTestCount&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;0件&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textColor=&quot;#999999&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&lt;/androidx.cardview.widget.CardView&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_study_checklist.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_study_checklist.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;!-- 日付ヘッダー --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textDateHeader&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:textColor=&quot;@android:color/holo_blue_dark&quot;&#10;        android:paddingTop=&quot;8dp&quot;&#10;        android:paddingBottom=&quot;4dp&quot;&#10;        android:visibility=&quot;gone&quot; /&gt;&#10;&#10;    &lt;!-- チェックボックス付き科目名 --&gt;&#10;    &lt;CheckBox&#10;        android:id=&quot;@+id/checkboxSubject&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:paddingStart=&quot;16dp&quot;&#10;        android:paddingEnd=&quot;8dp&quot;&#10;        android:paddingTop=&quot;4dp&quot;&#10;        android:paddingBottom=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_study_history.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_study_history.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:layout_marginBottom=&quot;8dp&quot;&#10;    app:cardCornerRadius=&quot;8dp&quot;&#10;    app:cardElevation=&quot;4dp&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;12dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/textStudyDate&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;@android:color/holo_blue_dark&quot;&#10;            android:text=&quot;2025/08/03&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/textSubjectInfo&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:text=&quot;1限: 数学&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/textStudyTime&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:textColor=&quot;@android:color/darker_gray&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:text=&quot;勉強完了: 08:30&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/androidx.cardview.widget.CardView&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>