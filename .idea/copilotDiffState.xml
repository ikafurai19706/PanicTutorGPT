<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.chatait.panictutorgpt&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.chatait.panictutorgpt&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.code.gson:gson:2.13.1&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.chatait.panictutorgpt&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.chatait.panictutorgpt&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.code.gson:gson:2.13.1&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PanicTutorGPT&quot;&gt;&#10;        &#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- バックグラウンド脅迫通知サービス --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.ThreatNotificationService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/MainActivity.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.os.Bundle&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications&#10;            )&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt&#10;&#10;import android.app.*&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.os.*&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.*&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.*&#10;import com.chatait.panictutorgpt.databinding.ActivityMainBinding&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import java.util.Random&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private val CHANNEL_ID = &quot;default_channel&quot;&#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var geminiService: GeminiService&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // GeminiServiceを初期化&#10;        geminiService = GeminiService(this)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications)&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        createNotificationChannel()&#10;        requestNotificationPermission()&#10;&#10;        // アプリ起動時にAPIキーが設定されていない場合はダイアログを表示&#10;        checkAndShowApiKeyDialog()&#10;&#10;        // バックグラウンド脅迫サービスを開始&#10;        startThreatService()&#10;    }&#10;&#10;    private fun startThreatService() {&#10;        val serviceIntent = Intent(this, com.chatait.panictutorgpt.service.ThreatNotificationService::class.java)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            startForegroundService(serviceIntent)&#10;        } else {&#10;            startService(serviceIntent)&#10;        }&#10;        Log.d(&quot;MainActivity&quot;, &quot;脅迫サービスを開始しました&quot;)&#10;    }&#10;&#10;    private fun checkAndShowApiKeyDialog() {&#10;        if (!geminiService.isApiKeySet()) {&#10;            showApiKeyDialog()&#10;        }&#10;    }&#10;&#10;    private fun showApiKeyDialog() {&#10;        val editText = EditText(this)&#10;        editText.hint = &quot;Gemini API キーを入力してください&quot;&#10;&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;API キー設定&quot;)&#10;            .setMessage(&quot;Gemini API を使用してリマインダーメッセージを生成するため、API キーが必要です。&quot;)&#10;            .setView(editText)&#10;            .setPositiveButton(&quot;設定&quot;) { _, _ -&gt;&#10;                val apiKey = editText.text.toString().trim()&#10;                if (apiKey.isNotEmpty()) {&#10;                    geminiService.saveApiKey(apiKey)&#10;                    Toast.makeText(this, &quot;API キーが設定されました&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;API キーが空です&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;後で&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;                Toast.makeText(this, &quot;デフォルトメッセージを使用します&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Default Channel&quot;&#10;            val descriptionText = &quot;Default notification channel&quot;&#10;            val importance = NotificationManager.IMPORTANCE_DEFAULT&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun requestNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                ActivityCompat.requestPermissions(&#10;                    this,&#10;                    arrayOf(android.Manifest.permission.POST_NOTIFICATIONS),&#10;                    101&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendTestReminder() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val message = geminiService.generateReminderMessage()&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot;テスト勉強リマインダー&quot;, message)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;リマインダー送信時にエラーが発生しました: ${e.message}&quot;, e)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot;テスト勉強リマインダー&quot;, &quot;勉強を始めましょう！&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun showNotification(title: String, message: String) {&#10;        // 通知をタップした時にアプリを起動するためのIntent&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentTitle(title)&#10;            .setContentText(message)&#10;            .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;            .setAutoCancel(true)&#10;            .setContentIntent(pendingIntent) // 通知タップ時の動作を設定&#10;&#10;        with(NotificationManagerCompat.from(this)) {&#10;            if (ActivityCompat.checkSelfPermission(&#10;                    this@MainActivity,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                notify(Random().nextInt(), builder.build())&#10;            }&#10;        }&#10;    }&#10;&#10;    fun showApiKeySettingDialog() {&#10;        showApiKeyDialog()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // アプリがバックグラウンドに移行した時に脅迫メッセージをチェック&#10;        checkAndSendThreatMessage()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        // アプリが完全に閉じられた時にも脅迫メッセージをチェック&#10;        checkAndSendThreatMessage()&#10;    }&#10;&#10;    private fun checkAndSendThreatMessage() {&#10;        val scheduleRepository = com.chatait.panictutorgpt.data.ScheduleRepository(this)&#10;        val upcomingTests = getTestsWithinOneWeek(scheduleRepository)&#10;&#10;        if (upcomingTests.isNotEmpty()) {&#10;            sendThreatNotification(upcomingTests)&#10;        }&#10;    }&#10;&#10;    private fun getTestsWithinOneWeek(scheduleRepository: com.chatait.panictutorgpt.data.ScheduleRepository): List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = java.text.SimpleDateFormat(&quot;yyyy/MM/dd&quot;, java.util.Locale.getDefault())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        return schedules.mapNotNull { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    val subjects = scheduleItem.subjects.filter { it.isNotBlank() }&#10;                    if (subjects.isNotEmpty()) {&#10;                        Pair(scheduleItem.date, subjects)&#10;                    } else null&#10;                } else null&#10;            } catch (e: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendThreatNotification(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val testInfo = upcomingTests.joinToString(&quot;、&quot;) { (date, subjects) -&gt;&#10;                    &quot;${date}: ${subjects.joinToString(&quot;、&quot;)}&quot;&#10;                }&#10;&#10;                val threatMessage = geminiService.generateThreatMessage(testInfo)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    showNotification(&quot; 緊急警告 &quot;, threatMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;脅迫メッセージ送信時にエラー: ${e.message}&quot;, e)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    val fallbackMessage = generateFallbackThreatMessage(upcomingTests)&#10;                    showNotification(&quot; 緊急警告 &quot;, fallbackMessage)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generateFallbackThreatMessage(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;): String {&#10;        val subjects = upcomingTests.flatMap { it.second }.distinct()&#10;        val threatMessages = listOf(&#10;            &quot;逃げても無駄です...${subjects.joinToString(&quot;、&quot;)}のテストが迫っています...&quot;,&#10;            &quot;アプリを閉じても現実は変わりません。${subjects.joinToString(&quot;、&quot;)}の準備はできていますか？&quot;,&#10;            &quot;恐怖の時間が始まります...${subjects.joinToString(&quot;、&quot;)}で良い点を取れなければ...&quot;,&#10;            &quot;運命の日が近づいています。${subjects.joinToString(&quot;、&quot;)}の勉強を怠れば後悔することになります...&quot;,&#10;            &quot;暗闇の中で${subjects.joinToString(&quot;、&quot;)}のテストがあなたを見つめています...&quot;,&#10;            &quot;時間は容赦なく過ぎています...${subjects.joinToString(&quot;、&quot;)}の準備はまだ終わっていませんね？&quot;&#10;        )&#10;        return threatMessages.random()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/GeminiService.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;&quot;&quot;&#10;                                        あなたは学生のテスト勉強を促す、脅迫的なリマインダーアシスタントです。&#10;                                        日本語で、短く、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。&#10;                                    &quot;&quot;&quot;.trimIndent()&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;&quot;&quot;&#10;                                        あなたは学生のテスト勉強を促す、脅迫的なリマインダーアシスタントです。&#10;                                        日本語で、短く、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。&#10;                                    &quot;&quot;&quot;.trimIndent()&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun generateThreatMessage(testInfo: String): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバック脅迫メッセージを使用します。&quot;)&#10;                    return@withContext getThreatFallbackMessage(testInfo)&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini 2.0 Flash APIで脅迫メッセージを生成します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;あなたは学生に恐怖を与える悪魔的なテスト監督です。以下のテスト情報を元に、日本語で非常に脅迫的で恐ろしいメッセージを生成してください。アプリを閉じて逃げようとした学生を追い詰めるような、背筋が凍るような内容にしてください。絵文字を使って恐怖感を演出し、50文字以内で作成してください。\n\nテスト情報: $testInfo&quot;&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIから脅迫メッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージレスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージAPI request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;脅迫メッセージ予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getThreatFallbackMessage(testInfo)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    private fun getThreatFallbackMessage(testInfo: String): String {&#10;        val threatMessages = listOf(&#10;            &quot; 逃げても無駄...テストの恐怖があなたを追いかけます &quot;,&#10;            &quot; アプリを閉じても現実は変わらない...準備はできていますか？ &quot;,&#10;            &quot; 暗闇からテストがあなたを見つめています... &quot;,&#10;            &quot;⚡ 運命の時が近づいています...震えて待て ⚡&quot;,&#10;            &quot;️ 嵐のようなテストがやってきます...覚悟はいいですか？ ️&quot;,&#10;            &quot; 時間は容赦なく過ぎています...後悔の時が来る &quot;&#10;        )&#10;        val selectedMessage = threatMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバック脅迫メッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/OpenAIService.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class GeminiService(private val context: Context) {&#10;&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = Gson()&#10;&#10;    private fun getApiKey(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;api_key&quot;, null)&#10;    }&#10;&#10;    fun saveApiKey(apiKey: String) {&#10;        val prefs = context.getSharedPreferences(&quot;gemini_config&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            putString(&quot;api_key&quot;, apiKey)&#10;        }&#10;    }&#10;&#10;    fun isApiKeySet(): Boolean {&#10;        return !getApiKey().isNullOrEmpty()&#10;    }&#10;&#10;    suspend fun generateReminderMessage(): String {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val apiKey = getApiKey()&#10;                if (apiKey.isNullOrEmpty()) {&#10;                    Log.w(&quot;GeminiService&quot;, &quot;APIキーが設定されていません。フォールバックメッセージを使用します。&quot;)&#10;                    return@withContext getFallbackMessage()&#10;                }&#10;&#10;                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIを呼び出します...&quot;)&#10;&#10;                val requestBody = GeminiRequest(&#10;                    contents = listOf(&#10;                        Content(&#10;                            parts = listOf(&#10;                                Part(&#10;                                    text = &quot;あなたは学生のテスト勉強を促す、少し脅迫的だが愛のあるリマインダーアシスタントです。日本語で、短く（30文字以内）、勉強を促す緊迫感のあるメッセージを1つだけ生成してください。テスト勉強をサボっている学生への短いリマインダーメッセージをお願いします。&quot;&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                val json = gson.toJson(requestBody)&#10;                val body = json.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent&quot;)&#10;                    .addHeader(&quot;X-goog-api-key&quot;, apiKey)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(body)&#10;                    .build()&#10;&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val responseBody = response.body?.string()&#10;                    responseBody?.let { responseString -&gt;&#10;                        try {&#10;                            val geminiResponse = gson.fromJson(responseString, GeminiResponse::class.java)&#10;                            val aiMessage = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()&#10;                            if (!aiMessage.isNullOrEmpty()) {&#10;                                Log.d(&quot;GeminiService&quot;, &quot;Gemini APIからメッセージを取得しました: $aiMessage&quot;)&#10;                                return@withContext aiMessage&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;GeminiService&quot;, &quot;レスポンス解析エラー: ${e.message}&quot;)&#10;                            Log.e(&quot;GeminiService&quot;, &quot;Response body: $responseString&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GeminiService&quot;, &quot;API request failed: ${response.code} - ${response.message}&quot;)&#10;                    Log.e(&quot;GeminiService&quot;, &quot;Response body: ${response.body?.string()}&quot;)&#10;                }&#10;&#10;                return@withContext getFallbackMessage()&#10;&#10;            } catch (e: IOException) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;ネットワークエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GeminiService&quot;, &quot;予期しないエラー: ${e.message}&quot;)&#10;                return@withContext getFallbackMessage()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getFallbackMessage(): String {&#10;        val fallbackMessages = listOf(&#10;            &quot;締め切りが迫っています！今すぐ勉強を始めましょう！&quot;,&#10;            &quot;見て見ぬふりはできません...テスト準備は大丈夫ですか？&quot;,&#10;            &quot;あなたの勉強状況が気になります。頑張って！&quot;,&#10;            &quot;時間は刻一刻と過ぎています。準備はお済みですか？&quot;,&#10;            &quot;本当にそれでいいのですか？今から始めれば間に合います！&quot;,&#10;            &quot;テスト当日まであとわずか...準備を忘れずに！&quot;,&#10;            &quot;勉強しないと...後悔することになりますよ？&quot;&#10;        )&#10;        val selectedMessage = fallbackMessages.random()&#10;        Log.d(&quot;GeminiService&quot;, &quot;フォールバックメッセージを使用: $selectedMessage&quot;)&#10;        return selectedMessage&#10;    }&#10;&#10;    // Gemini API用データクラス定義&#10;    data class GeminiRequest(&#10;        val contents: List&lt;Content&gt;&#10;    )&#10;&#10;    data class Content(&#10;        val parts: List&lt;Part&gt;&#10;    )&#10;&#10;    data class Part(&#10;        val text: String&#10;    )&#10;&#10;    data class GeminiResponse(&#10;        val candidates: List&lt;Candidate&gt;?&#10;    )&#10;&#10;    data class Candidate(&#10;        val content: ContentResponse?&#10;    )&#10;&#10;    data class ContentResponse(&#10;        val parts: List&lt;PartResponse&gt;?&#10;    )&#10;&#10;    data class PartResponse(&#10;        val text: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/data/ScheduleRepository.kt" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import com.chatait.panictutorgpt.ui.dashboard.ScheduleItem&#10;&#10;class ScheduleRepository(context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;schedule_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        private const val KEY_SCHEDULE_PREFIX = &quot;schedule_&quot;&#10;        private const val KEY_SCHEDULE_DATES = &quot;schedule_dates&quot;&#10;    }&#10;&#10;    fun saveSchedules(schedules: List&lt;ScheduleItem&gt;) {&#10;        prefs.edit {&#10;            // すべての既存のスケジュールをクリア&#10;            val existingDates = getScheduleDates()&#10;            existingDates.forEach { date -&gt;&#10;                for (i in 0..5) { // 0限〜5限（6時限分）&#10;                    remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;                }&#10;            }&#10;            &#10;            // 新しいスケジュールを保存&#10;            val dates = schedules.map { it.date }.toSet()&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;            &#10;            schedules.forEach { schedule -&gt;&#10;                schedule.subjects.forEachIndexed { index, subject -&gt;&#10;                    putString(&quot;${KEY_SCHEDULE_PREFIX}${schedule.date}_subject_$index&quot;, subject)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadSchedules(): MutableList&lt;ScheduleItem&gt; {&#10;        val schedules = mutableListOf&lt;ScheduleItem&gt;()&#10;        val dates = getScheduleDates()&#10;        &#10;        dates.forEach { date -&gt;&#10;            val subjects = mutableListOf&lt;String&gt;()&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                val subject = prefs.getString(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;, &quot;&quot;) ?: &quot;&quot;&#10;                subjects.add(subject)&#10;            }&#10;            &#10;            // 空でない科目が1つでもあればスケジュールに追加&#10;            if (subjects.any { it.isNotEmpty() }) {&#10;                schedules.add(ScheduleItem(date, subjects))&#10;            }&#10;        }&#10;        &#10;        return schedules.sortedBy { it.date }.toMutableList()&#10;    }&#10;&#10;    fun deleteSchedule(date: String) {&#10;        prefs.edit {&#10;            for (i in 0..5) { // 0限〜5限（6時限分）&#10;                remove(&quot;${KEY_SCHEDULE_PREFIX}${date}_subject_$i&quot;)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.remove(date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;&#10;    fun addOrUpdateSchedule(scheduleItem: ScheduleItem) {&#10;        prefs.edit {&#10;            scheduleItem.subjects.forEachIndexed { index, subject -&gt;&#10;                putString(&quot;${KEY_SCHEDULE_PREFIX}${scheduleItem.date}_subject_$index&quot;, subject)&#10;            }&#10;            &#10;            val dates = getScheduleDates().toMutableSet()&#10;            dates.add(scheduleItem.date)&#10;            putStringSet(KEY_SCHEDULE_DATES, dates)&#10;        }&#10;    }&#10;    &#10;    private fun getScheduleDates(): Set&lt;String&gt; {&#10;        return prefs.getStringSet(KEY_SCHEDULE_DATES, emptySet()) ?: emptySet()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/service/ThreatNotificationService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/service/ThreatNotificationService.kt" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.service&#10;&#10;import android.app.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import kotlinx.coroutines.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class ThreatNotificationService : Service() {&#10;&#10;    private val CHANNEL_ID = &quot;threat_channel&quot;&#10;    private val NOTIFICATION_ID = 1001&#10;    private lateinit var geminiService: GeminiService&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var serviceJob: Job? = null&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        geminiService = GeminiService(this)&#10;        scheduleRepository = ScheduleRepository(this)&#10;        createNotificationChannel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが開始されました&quot;)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        startForegroundService()&#10;        startThreatMonitoring()&#10;        return START_STICKY // サービスが強制終了されても自動的に再起動&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;脅迫監視システム&quot;)&#10;            .setContentText(&quot;テスト期間中の逃亡を監視中...&quot;)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    private fun startThreatMonitoring() {&#10;        serviceJob = CoroutineScope(Dispatchers.IO + SupervisorJob()).launch {&#10;            while (isActive) {&#10;                try {&#10;                    checkAndSendThreatMessage()&#10;                    delay(TimeUnit.MINUTES.toMillis(30)) // 30分ごとにチェック&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージチェック中にエラー: ${e.message}&quot;)&#10;                    delay(TimeUnit.MINUTES.toMillis(10)) // エラー時は10分後に再試行&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkAndSendThreatMessage() {&#10;        val upcomingTests = getTestsWithinOneWeek()&#10;        &#10;        if (upcomingTests.isNotEmpty()) {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のテストが発見されました: $upcomingTests&quot;)&#10;            sendThreatNotification(upcomingTests)&#10;        } else {&#10;            Log.d(&quot;ThreatService&quot;, &quot;1週間以内のテストはありません&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getTestsWithinOneWeek(): List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;        val currentTime = System.currentTimeMillis()&#10;        val oneWeekFromNow = currentTime + (7 * 24 * 60 * 60 * 1000)&#10;&#10;        return schedules.mapNotNull { scheduleItem -&gt;&#10;            try {&#10;                val testDate = dateFormat.parse(scheduleItem.date)?.time&#10;                if (testDate != null &amp;&amp; testDate in currentTime..oneWeekFromNow) {&#10;                    val subjects = scheduleItem.subjects.filter { it.isNotBlank() }&#10;                    if (subjects.isNotEmpty()) {&#10;                        Pair(scheduleItem.date, subjects)&#10;                    } else null&#10;                } else null&#10;            } catch (e: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun sendThreatNotification(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;) {&#10;        try {&#10;            val testInfo = upcomingTests.joinToString(&quot;、&quot;) { (date, subjects) -&gt;&#10;                &quot;${date}: ${subjects.joinToString(&quot;、&quot;)}&quot;&#10;            }&#10;&#10;            val threatMessage = geminiService.generateThreatMessage(testInfo)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, threatMessage)&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(&quot;ThreatService&quot;, &quot;脅迫メッセージ生成エラー: ${e.message}&quot;)&#10;            val fallbackMessage = generateFallbackThreatMessage(upcomingTests)&#10;            showThreatNotification(&quot; 逃亡者発見 &quot;, fallbackMessage)&#10;        }&#10;    }&#10;&#10;    private fun showThreatNotification(title: String, message: String) {&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setContentTitle(title)&#10;            .setContentText(message)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;            .setContentIntent(pendingIntent)&#10;            .setVibrate(longArrayOf(0, 1000, 500, 1000)) // 振動パターン&#10;            .setLights(0xFFFF0000.toInt(), 1000, 1000) // 赤色LEDライト&#10;            .build()&#10;&#10;        with(NotificationManagerCompat.from(this)) {&#10;            if (ActivityCompat.checkSelfPermission(&#10;                    this@ThreatNotificationService,&#10;                    android.Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                notify(Random().nextInt(1000, 9999), notification)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知を送信しました: $message&quot;)&#10;    }&#10;&#10;    private fun generateFallbackThreatMessage(upcomingTests: List&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;): String {&#10;        val subjects = upcomingTests.flatMap { it.second }.distinct()&#10;        val threatMessages = listOf(&#10;            &quot; どこに隠れても無駄です...${subjects.joinToString(&quot;、&quot;)}のテストから逃れることはできません &quot;,&#10;            &quot; アプリを閉じて逃げたつもりですか？${subjects.joinToString(&quot;、&quot;)}の恐怖があなたを追いかけます &quot;,&#10;            &quot; 暗闇の中から${subjects.joinToString(&quot;、&quot;)}のテストがあなたを見つめています... &quot;,&#10;            &quot;⚡ 運命から逃れることはできません...${subjects.joinToString(&quot;、&quot;)}の審判の時が来ました ⚡&quot;,&#10;            &quot;️ 嵐のような${subjects.joinToString(&quot;、&quot;)}のテストがあなたを襲います...覚悟はできていますか？ ️&quot;,&#10;            &quot; 時間は刻一刻と過ぎています...${subjects.joinToString(&quot;、&quot;)}の準備を怠った代償を払う時です &quot;&#10;        )&#10;        return threatMessages.random()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;脅迫通知チャンネル&quot;&#10;            val descriptionText = &quot;テスト期間中の脅迫メッセージ&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;                enableVibration(true)&#10;                enableLights(true)&#10;                lightColor = 0xFFFF0000.toInt()&#10;            }&#10;            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        serviceJob?.cancel()&#10;        Log.d(&quot;ThreatService&quot;, &quot;脅迫通知サービスが停止されました&quot;)&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/DashboardFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(scheduleList) { dateToDelete -&gt;&#10;            // 削除処理&#10;            scheduleRepository.deleteSchedule(dateToDelete)&#10;            scheduleList.clear()&#10;            scheduleList.addAll(scheduleRepository.loadSchedules())&#10;            adapter.notifyDataSetChanged()&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    errorText.visibility = View.VISIBLE&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.DatePicker&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.databinding.FragmentDashboardBinding&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import java.util.Calendar&#10;&#10;class DashboardFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDashboardBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleList: MutableList&lt;ScheduleItem&gt;&#10;    private lateinit var adapter: ScheduleAdapter&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val dashboardViewModel =&#10;            ViewModelProvider(this).get(DashboardViewModel::class.java)&#10;&#10;        _binding = FragmentDashboardBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        // ScheduleRepositoryを初期化&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        // 保存されたスケジュールを読み込み&#10;        scheduleList = scheduleRepository.loadSchedules()&#10;&#10;        // RecyclerView初期化&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.scheduleList)&#10;        adapter = ScheduleAdapter(scheduleList) { dateToDelete -&gt;&#10;            // 削除処理&#10;            scheduleRepository.deleteSchedule(dateToDelete)&#10;            scheduleList.clear()&#10;            scheduleList.addAll(scheduleRepository.loadSchedules())&#10;            adapter.notifyDataSetChanged()&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;&#10;        // 予定追加ボタンのクリックリスナー&#10;        binding.dashboardEntryButton.setOnClickListener {&#10;            val calendar = Calendar.getInstance()&#10;            val inflater = LayoutInflater.from(requireContext())&#10;            val datePickerView = inflater.inflate(R.layout.dialog_custom_date_picker, null)&#10;            val datePicker = datePickerView.findViewById&lt;DatePicker&gt;(R.id.customDatePicker)&#10;            datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), null)&#10;            // 過去日付を選択不可に&#10;            datePicker.minDate = calendar.timeInMillis&#10;&#10;            val dateDialog = AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;テストの日付を選択…&quot;)&#10;                .setView(datePickerView)&#10;                .setPositiveButton(&quot;次へ&quot;) { _, _ -&gt;&#10;                    val year = datePicker.year&#10;                    val month = datePicker.month&#10;                    val day = datePicker.dayOfMonth&#10;                    showAddScheduleForm(year, month, day)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .create()&#10;            dateDialog.show()&#10;        }&#10;&#10;        dashboardViewModel.text.observe(viewLifecycleOwner) {&#10;&#10;        }&#10;        return root&#10;    }&#10;&#10;    // 日付と教科名を入力する関数（引数で日付を受け取る）&#10;    private fun showAddScheduleForm(year: Int, month: Int, day: Int) {&#10;        val context = requireContext()&#10;        val inflater = LayoutInflater.from(context)&#10;        val dialogView = inflater.inflate(R.layout.dialog_add_schedule, null)&#10;        val subject1 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject1)&#10;        val subject2 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject2)&#10;        val subject3 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject3)&#10;        val subject4 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject4)&#10;        val subject5 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject5)&#10;        val subject6 = dialogView.findViewById&lt;EditText&gt;(R.id.editTextSubject6)&#10;        val errorText = dialogView.findViewById&lt;TextView&gt;(R.id.textError)&#10;&#10;        val date = &quot;%04d/%02d/%02d&quot;.format(year, month + 1, day)&#10;        // 既存データがあれば初期値セット&#10;        val existing = scheduleList.find { it.date == date }&#10;        if (existing != null) {&#10;            val fields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            existing.subjects.forEachIndexed { i, value -&gt;&#10;                if (i &lt; fields.size) fields[i].setText(value)&#10;            }&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;科目名を入力…&quot;)&#10;            .setView(dialogView)&#10;            .setPositiveButton(&quot;追加&quot;, null) // 後でリスナーを設定&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;        dialog.setOnShowListener {&#10;            val button = dialog.getButton(AlertDialog.BUTTON_POSITIVE)&#10;            val subjectFields = listOf(subject1, subject2, subject3, subject4, subject5, subject6)&#10;            val updateError = {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                errorText.visibility = if (subjects.all { it.isBlank() }) View.VISIBLE else View.GONE&#10;            }&#10;            button.setOnClickListener {&#10;                val subjects = subjectFields.map { it.text.toString() }&#10;                if (subjects.all { it.isBlank() }) {&#10;                    // 既存データがある場合は削除確認ダイアログを表示&#10;                    if (existing != null) {&#10;                        // 一週間前チェック&#10;                        val testDate = Calendar.getInstance()&#10;                        val dateParts = date.split(&quot;/&quot;)&#10;                        testDate.set(dateParts[0].toInt(), dateParts[1].toInt() - 1, dateParts[2].toInt())&#10;&#10;                        val today = Calendar.getInstance()&#10;                        val oneWeekFromNow = Calendar.getInstance()&#10;                        oneWeekFromNow.add(Calendar.DAY_OF_YEAR, 7)&#10;&#10;                        if (testDate.before(oneWeekFromNow)) {&#10;                            // 一週間前を切っている場合は削除不可&#10;                            val warningDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;削除できません&quot;)&#10;                                .setMessage(&quot;テスト一週間前を切った予定は削除できません。&quot;)&#10;                                .setPositiveButton(&quot;OK&quot;, null)&#10;                                .create()&#10;                            warningDialog.show()&#10;                        } else {&#10;                            // 一週間前を切っていない場合は削除確認&#10;                            val deleteDialog = AlertDialog.Builder(context)&#10;                                .setTitle(&quot;確認&quot;)&#10;                                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                                    // 既存のスケジュールを削除&#10;                                    scheduleRepository.deleteSchedule(date)&#10;                                    // UIを更新&#10;                                    scheduleList.clear()&#10;                                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                                    adapter.notifyDataSetChanged()&#10;                                    dialog.dismiss()&#10;                                }&#10;                                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                                .create()&#10;                            deleteDialog.show()&#10;                        }&#10;                    } else {&#10;                        errorText.visibility = View.VISIBLE&#10;                    }&#10;                } else {&#10;                    errorText.visibility = View.GONE&#10;                    // ScheduleRepositoryを使用してデータを保存&#10;                    val scheduleItem = ScheduleItem(date, subjects)&#10;                    scheduleRepository.addOrUpdateSchedule(scheduleItem)&#10;&#10;                    // UIを更新&#10;                    scheduleList.clear()&#10;                    scheduleList.addAll(scheduleRepository.loadSchedules())&#10;                    adapter.notifyDataSetChanged()&#10;                    dialog.dismiss()&#10;                }&#10;            }&#10;            // 入力時にエラー非表示&#10;            subjectFields.forEach { editText -&gt;&#10;                editText.addTextChangedListener(object : android.text.TextWatcher {&#10;                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                        updateError()&#10;                    }&#10;                    override fun afterTextChanged(s: android.text.Editable?) {}&#10;                })&#10;            }&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleAdapter.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;import android.animation.ValueAnimator&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.chatait.panictutorgpt.R&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ScheduleAdapter(&#10;    private val items: MutableList&lt;ScheduleItem&gt;,&#10;    private val onDeleteClick: ((String) -&gt; Unit)? = null,&#10;    private val onItemClick: ((ScheduleItem) -&gt; Unit)? = null,&#10;    private val onEmptyScheduleDelete: ((String) -&gt; Unit)? = null&#10;) : RecyclerView.Adapter&lt;ScheduleAdapter.ViewHolder&gt;() {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#10;    private var longPressRunnable: Runnable? = null&#10;&#10;    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val dateText: TextView = view.findViewById(R.id.scheduleDate)&#10;        val subjectsText: TextView = view.findViewById(R.id.scheduleSubjects)&#10;        val cardView: View = view&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_schedule, parent, false)&#10;        return ViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val item = items[position]&#10;        holder.dateText.text = item.date&#10;&#10;        // 空でない科目のみ表示&#10;        val nonEmptySubjects = item.subjects.withIndex()&#10;            .filter { it.value.isNotBlank() }&#10;&#10;        holder.subjectsText.text = if (nonEmptySubjects.isEmpty()) {&#10;            &quot;テスト予定なし&quot;&#10;        } else {&#10;            nonEmptySubjects.joinToString(&quot;\n&quot;) { (i, s) -&gt; &quot;${i+1}限: $s&quot; }&#10;        }&#10;&#10;        // クリックリスナー設定&#10;        holder.cardView.setOnClickListener {&#10;            onItemClick?.invoke(item)&#10;        }&#10;&#10;        // タッチリスナー設定（長押し処理）&#10;        holder.cardView.setOnTouchListener { view, event -&gt;&#10;            when (event.action) {&#10;                MotionEvent.ACTION_DOWN -&gt; {&#10;                    startLongPressAnimation(view)&#10;                    startLongPressTimer(view, item)&#10;                    true&#10;                }&#10;                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                    cancelLongPress(view)&#10;                    false&#10;                }&#10;                else -&gt; false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    private fun startLongPressAnimation(view: View) {&#10;        val originalColor = Color.WHITE // デフォルトの白色&#10;        val pressedColor = Color.RED // プレス時の赤色&#10;&#10;        val colorAnimator = ValueAnimator.ofArgb(originalColor, pressedColor)&#10;        colorAnimator.duration = 5000 // 5秒&#10;        colorAnimator.addUpdateListener { animator -&gt;&#10;            view.setBackgroundColor(animator.animatedValue as Int)&#10;        }&#10;        colorAnimator.start()&#10;&#10;        view.tag = colorAnimator&#10;    }&#10;&#10;    private fun startLongPressTimer(view: View, item: ScheduleItem) {&#10;        longPressRunnable = Runnable {&#10;            showForcedDeleteDialog(view.context, item)&#10;        }&#10;        longPressHandler.postDelayed(longPressRunnable!!, 5000) // 5秒&#10;    }&#10;&#10;    private fun cancelLongPress(view: View) {&#10;        longPressRunnable?.let { runnable -&gt;&#10;            longPressHandler.removeCallbacks(runnable)&#10;            longPressRunnable = null&#10;        }&#10;&#10;        // アニメーション停止と色をリセット&#10;        (view.tag as? ValueAnimator)?.cancel()&#10;        view.setBackgroundColor(Color.WHITE) // 白色にリセット&#10;    }&#10;&#10;    private fun showForcedDeleteDialog(context: android.content.Context, item: ScheduleItem) {&#10;        AlertDialog.Builder(context)&#10;            .setTitle(&quot;削除確認&quot;)&#10;            .setMessage(&quot;本当に削除しますか？この操作は取り消せません。&quot;)&#10;            .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                onDeleteClick?.invoke(item.id)&#10;            }&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun isWithinOneWeek(dateString: String): Boolean {&#10;        return try {&#10;            val testDate = dateFormat.parse(dateString)&#10;            val currentDate = Date()&#10;            val oneWeekFromNow = Calendar.getInstance().apply {&#10;                time = currentDate&#10;                add(Calendar.DAY_OF_YEAR, 7)&#10;            }.time&#10;&#10;            testDate != null &amp;&amp; testDate.before(oneWeekFromNow)&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    fun showDeleteConfirmationForEmptySchedule(context: android.content.Context, item: ScheduleItem) {&#10;        if (isWithinOneWeek(item.date)) {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除不可&quot;)&#10;                .setMessage(&quot;一週間前を切ったテストの予定は削除できません。&quot;)&#10;                .setPositiveButton(&quot;OK&quot;, null)&#10;                .show()&#10;        } else {&#10;            AlertDialog.Builder(context)&#10;                .setTitle(&quot;削除確認&quot;)&#10;                .setMessage(&quot;この日のテスト予定を削除します。よろしいですか？&quot;)&#10;                .setPositiveButton(&quot;削除&quot;) { _, _ -&gt;&#10;                    onEmptyScheduleDelete?.invoke(item.id)&#10;                }&#10;                .setNegativeButton(&quot;キャンセル&quot;, null)&#10;                .show()&#10;        }&#10;    }&#10;&#10;    fun removeItem(itemId: String) {&#10;        val position = items.indexOfFirst { it.id == itemId }&#10;        if (position != -1) {&#10;            items.removeAt(position)&#10;            notifyItemRemoved(position)&#10;        }&#10;    }&#10;&#10;    fun updateItem(updatedItem: ScheduleItem) {&#10;        val position = items.indexOfFirst { it.id == updatedItem.id }&#10;        if (position != -1) {&#10;            items[position] = updatedItem&#10;            notifyItemChanged(position)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/dashboard/ScheduleItem.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.dashboard&#10;&#10;data class ScheduleItem(&#10;    val date: String, // 例: &quot;2025/08/03&quot;&#10;    val subjects: List&lt;String&gt;, // 1限～6限の科目名&#10;    val id: String = java.util.UUID.randomUUID().toString()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/home/HomeFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 40),  // 2限&#10;        Pair(13, 0),   // 3限&#10;        Pair(14, 40),  // 4限&#10;        Pair(16, 20),  // 5限&#10;        Pair(18, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            (activity as? MainActivity)?.showNotification()&#10;            Toast.makeText(context, &quot;リマインダー通知を送信しました！&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val geminiService = GeminiService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        handler.removeCallbacks(updateTimeRunnable)&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.home&#10;&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.view.isVisible&#10;import androidx.fragment.app.Fragment&#10;import com.chatait.panictutorgpt.MainActivity&#10;import com.chatait.panictutorgpt.R&#10;import com.chatait.panictutorgpt.data.GeminiService&#10;import com.chatait.panictutorgpt.data.ScheduleRepository&#10;import com.chatait.panictutorgpt.databinding.FragmentHomeBinding&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var closestTestTimeMillis: Long? = null&#10;&#10;    // ▼▼▼ 大学の時間割に合わせてここを編集してください ▼▼▼&#10;    // (時, 分) のペアで授業開始時刻を定義&#10;    private val classStartTimes = listOf(&#10;        Pair(9, 0),    // 1限&#10;        Pair(10, 40),  // 2限&#10;        Pair(13, 0),   // 3限&#10;        Pair(14, 40),  // 4限&#10;        Pair(16, 20),  // 5限&#10;        Pair(18, 0)    // 6限&#10;    )&#10;    // ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲ ▲▲▲&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val updateTimeRunnable = object : Runnable {&#10;        override fun run() {&#10;            updateDateTime()&#10;            updateCountdownView()&#10;            handler.postDelayed(this, 10)&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root = binding.root&#10;&#10;        scheduleRepository = ScheduleRepository(requireContext())&#10;&#10;        updateDateTime()&#10;        handler.post(updateTimeRunnable)&#10;&#10;        binding.registerButton.setOnClickListener {&#10;            (activity as? MainActivity)?.sendTestReminder()&#10;            Toast.makeText(context, &quot;リマインダー通知を送信しました！&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // 長押しでAPIキー設定ダイアログを表示&#10;        binding.registerButton.setOnLongClickListener {&#10;            (activity as? MainActivity)?.showApiKeySettingDialog()&#10;            true&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        findClosestTest()&#10;    }&#10;&#10;    /**&#10;     * 最も近いテストの日時を検索し、メンバ変数にセットする&#10;     */&#10;    private fun findClosestTest() {&#10;        val schedules = scheduleRepository.loadSchedules()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;&#10;        closestTestTimeMillis = schedules&#10;            .mapNotNull { scheduleItem -&gt;&#10;                try {&#10;                    val testDate = Calendar.getInstance().apply { time = dateFormat.parse(scheduleItem.date)!! }&#10;                    // その日の最初のテスト科目の開始時刻を取得&#10;                    val firstTestPeriod = scheduleItem.subjects.indexOfFirst { it.isNotBlank() }&#10;                    if (firstTestPeriod != -1 &amp;&amp; firstTestPeriod &lt; classStartTimes.size) {&#10;                        val (hour, minute) = classStartTimes[firstTestPeriod]&#10;                        testDate.set(Calendar.HOUR_OF_DAY, hour)&#10;                        testDate.set(Calendar.MINUTE, minute)&#10;                    }&#10;                    // 現在時刻より後のテストのみを対象とする&#10;                    if (testDate.timeInMillis &gt;= System.currentTimeMillis()) testDate else null&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;            .minByOrNull { it.timeInMillis }&#10;            ?.timeInMillis&#10;    }&#10;&#10;    /**&#10;     * カウントダウンの表示を更新する&#10;     */&#10;    private fun updateCountdownView() {&#10;        val targetTime = closestTestTimeMillis ?: run {&#10;            binding.countdownTestText.isVisible = false&#10;            return&#10;        }&#10;&#10;        val diffInMillis = targetTime - System.currentTimeMillis()&#10;&#10;        if (diffInMillis &lt; 0) {&#10;            binding.countdownTestText.text = &quot; テスト期間中です！&quot;&#10;            binding.countdownTestText.isVisible = true&#10;            return&#10;        }&#10;&#10;        val diffInDays = TimeUnit.MILLISECONDS.toDays(diffInMillis)&#10;&#10;        if (diffInDays &lt; 3) {&#10;            // 残り3日未満の場合：HH:mm:ss.SS形式で表示&#10;            val hours = TimeUnit.MILLISECONDS.toHours(diffInMillis)&#10;            val minutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis) % 60&#10;            val seconds = TimeUnit.MILLISECONDS.toSeconds(diffInMillis) % 60&#10;            val millis = (diffInMillis % 1000) / 10&#10;&#10;            binding.countdownTestText.text = String.format(&#10;                Locale.getDefault(),&#10;                &quot;テストまで残り %02d:%02d:%02d.%02d&quot;,&#10;                hours, minutes, seconds, millis&#10;            )&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else if (diffInDays &lt;= 7) {&#10;            // 残り7日以内の場合：日数で表示&#10;            binding.countdownTestText.text = &quot;次のテストまで あと${diffInDays + 1}日&quot;&#10;            binding.countdownTestText.isVisible = true&#10;&#10;        } else {&#10;            binding.countdownTestText.isVisible = false&#10;        }&#10;    }&#10;&#10;    private fun updateDateTime() {&#10;        val currentTime = Calendar.getInstance().time&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.SS&quot;, Locale.getDefault())&#10;        sdf.timeZone = TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;)&#10;        binding.dateTimeText.text = sdf.format(currentTime)&#10;    }&#10;&#10;    private fun showApiKeySettingDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_api_key_setting, null)&#10;        val editTextApiKey = dialogView.findViewById&lt;android.widget.EditText&gt;(R.id.editTextApiKey)&#10;        val buttonSave = dialogView.findViewById&lt;android.widget.Button&gt;(R.id.buttonSaveApiKey)&#10;        val textViewStatus = dialogView.findViewById&lt;android.widget.TextView&gt;(R.id.textViewStatus)&#10;&#10;        val geminiService = GeminiService(requireContext())&#10;&#10;        // 現在の設定状態を表示&#10;        if (geminiService.isApiKeySet()) {&#10;            textViewStatus.text = &quot;APIキーが設定されています&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            textViewStatus.text = &quot;APIキーが設定されていません&quot;&#10;            textViewStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Google Gemini API設定&quot;)&#10;            .setView(dialogView)&#10;            .setNegativeButton(&quot;キャンセル&quot;, null)&#10;            .create()&#10;&#10;        buttonSave.setOnClickListener {&#10;            val apiKey = editTextApiKey.text.toString().trim()&#10;            if (apiKey.isNotEmpty()) {&#10;                geminiService.saveApiKey(apiKey)&#10;                Toast.makeText(requireContext(), &quot;APIキーが保存されました&quot;, Toast.LENGTH_SHORT).show()&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;APIキーを入力してください&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        handler.removeCallbacks(updateTimeRunnable)&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chatait/panictutorgpt/ui/notifications/NotificationsFragment.kt" />
              <option name="originalContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;&#10;    // This property is only valid between onCreateView and&#10;    // onDestroyView.&#10;    private val binding get() = _binding!!&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;        return root&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.chatait.panictutorgpt.ui.notifications&#10;&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ArrayAdapter&#10;import android.widget.ListView&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.chatait.panictutorgpt.databinding.FragmentNotificationsBinding&#10;&#10;class NotificationsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentNotificationsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var listView: ListView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val notificationsViewModel =&#10;            ViewModelProvider(this).get(NotificationsViewModel::class.java)&#10;&#10;        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val textView: TextView = binding.textNotifications&#10;        notificationsViewModel.text.observe(viewLifecycleOwner) {&#10;            textView.text = it&#10;        }&#10;&#10;        // ListView を初期化し、通知履歴を表示&#10;        listView = binding.notificationList&#10;        loadNotificationHistory()&#10;&#10;        return root&#10;    }&#10;&#10;    private fun loadNotificationHistory() {&#10;        val prefs = requireContext().getSharedPreferences(&quot;notification_history&quot;, Context.MODE_PRIVATE)&#10;        val historySet = prefs.getStringSet(&quot;history&quot;, emptySet())&#10;&#10;        val historyList = if (historySet.isNullOrEmpty()) {&#10;            listOf(&quot;通知履歴はまだありません。\nHomeタブの「Entry」ボタンで通知を送信してください。&quot;)&#10;        } else {&#10;            historySet.map { historyItem -&gt;&#10;                val parts = historyItem.split(&quot;|&quot;)&#10;                val titleWithTime = parts.getOrNull(0) ?: &quot;タイトルなし&quot;&#10;                val message = parts.getOrNull(1) ?: &quot;メッセージなし&quot;&#10;                &quot;$titleWithTime\n$message&quot;&#10;            }.sortedDescending() // 新しい順に表示&#10;        }&#10;&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, historyList)&#10;        listView.adapter = adapter&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // フラグメントが表示されるたびに履歴を更新&#10;        loadNotificationHistory()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_add_schedule.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;3dp&quot;&#10;        android:layout_marginTop=&quot;18dp&quot;&#10;        android:hint=&quot;1限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject1&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;2限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject2&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;3限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject3&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;4限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject4&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;5限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject5&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        style=&quot;@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginHorizontal=&quot;24dp&quot;&#10;        android:layout_marginVertical=&quot;3dp&quot;&#10;        android:hint=&quot;6限&quot;&#10;        app:boxBackgroundMode=&quot;outline&quot;&gt;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextSubject6&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot; /&gt;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textError&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;科目名が入力されていません&quot;&#10;        android:textColor=&quot;#D32F2F&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_api_key_setting.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_api_key_setting.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Google Gemini API設定&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Google Gemini APIキーを入力してください。\nAPIキーを設定すると、AIが生成した個性的な通知メッセージを受け取れます。\n\n※ Gemini APIは無料で利用できます。&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Google Gemini APIキー&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&gt;&#10;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/editTextApiKey&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:inputType=&quot;textPassword&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/buttonSaveApiKey&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;保存&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textViewStatus&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;APIキーが設定されていません&quot;&#10;        android:textColor=&quot;@android:color/holo_red_dark&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_dashboard.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;CalendarView&#10;        android:id=&quot;@+id/calendarView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.dashboard.DashboardFragment&quot;&gt;&#10;&#10;    &lt;CalendarView&#10;        android:id=&quot;@+id/calendarView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@+id/scheduleList&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/scheduleList&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/calendarView&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/dashboardEntryButton&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- HomeのEntryボタンと同じものを下部に追加（horizontal margin 24dp） --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/dashboardEntryButton&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;24dp&quot;&#10;        android:layout_marginEnd=&quot;24dp&quot;&#10;        android:layout_marginBottom=&quot;100dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:text=&quot;テストの予定を追加&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintHorizontal_bias=&quot;1.0&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_notifications.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.notifications.NotificationsFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_notifications&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textAlignment=&quot;center&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:text=&quot;通知履歴&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;ListView&#10;        android:id=&quot;@+id/notification_list&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&#10;        android:divider=&quot;#CCCCCC&quot;&#10;        android:dividerHeight=&quot;1dp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@+id/text_notifications&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>